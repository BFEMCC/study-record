# 列表初始化

## 初始化赋值

`C++11`允许普通变量和数组也使用列表初始化赋值。

旧标准：

```c++
int a = 15;		//声明变量a，初始值为15
int b(15);		//声明变量b，初始值为15
int arr[]={ 1, 2, 3};//声明数组arr，3个元素1、2、3
```

`C++11`标准，（统一初始化列表，赋值等号可省略）：

```c++
int a = {15};			//声明变量a，初始值为15
int b{15};				//声明变量b，初始值为15
int arr[]{ 1, 2, 3};	//声明变量b，初始值为15
```

## 列表初始化防止类型收窄

类型收窄是指，变量赋值时发生隐式类型转换，因为数据精度或范围不匹配，导致精度丢失或数据丢失。

示例：

```c++
int main()
{
    int a = 1024;
	char b = a; //编译不会报错，但数据丢失,类型收窄
    printf("b = %din", b);//输出结果为0
    return 0;
}
```

使用列表初始化可以防止上面的类型收窄。

示例：

```c++
int main()
{
    int a = 1024;
    char b{ a };//编译时会直接报错，提示：C2397 从"int"转换到" char"需要收缩转换
	printf("b = %din", b);
	system("pause>nul");
}
```

注意！部分编译器会运行编译通过，但可能会有警告提示或者没有任何提示，但打印`b`的值时，仍然为`0`。

# 原始字面量

在 `C++11`中添加了定义原始字符串的字面量。

语法：

- `R “xxx(原始字符串)xxx”`
-  其中`()`两边的字符串是说明文字，类似注释，可以省略。
- `()`两边的字符必须一样，否则编译不通过。

原始字面量`R`可以直接表示字符串的实际含义，而不需要额外对字符串做转译或连接等操作。

原始字面量`R`可以直接赋值给`string`字符串，内容完全与原始字面量内的内容相同。

示例：

```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
    string str = "D:\hello\world\test.text";
    cout << str << endl;
    string str1 = "D:\\hello\\world\\test.text";
    cout << str1 << endl;
    string str2 = R"(D:\hello\world\test.text)";
    cout << str2 << endl;
 
    return 0;
}
```

输出结果：

```c++
D:helloworld    est.text
D:\hello\world\test.text
D:\hello\world\test.text
```

在`C++11`之前如果一个字符串分别写到了不同的行里边，需要加连接符，这种方式不仅繁琐，还破坏了表达式的原始含义，如果使用原始字面量就变得简单很多，很强直观，可读性强。

示例：

- 非`C++11`：

  ```c++
  #include<iostream>
  #include<string>
  using namespace std;
  int main()
  {
      string str = "<html>\
          <head>\
          <title>\
          海贼王\
          </title>\
          </head>\
          <body>\
          <p>\
          我是要成为海贼王的男人!!!\
          </p>\
          </body>\
          </html>";
      cout << str << endl;
      return 0;
  }
  ```

- `C++11`

  ```c++
  #include<iostream>
  #include<string>
  using namespace std;
  int main()
  {
      string str = R"(<html>
          <head>
          <title>
          海贼王
          </title>
          </head>
          <body>
          <p>
          我是要成为海贼王的男人!!!
          </p>
          </body>
          </html>)";
      cout << str << endl;
   
      return 0;
  }
  ```

# 自动类型推导

## `auto`自动类型推导

---

### 使用示例

---

`auto`的自动类型推导，用于从初始化表达式中推断出变量的数据类型。

从这个意义上讲，`auto`并非一种类型声明，而是一个类型声明时的占位符，编译器在编译时期会将`auto`替换为变量实际的类型。

通过`auto`的自动类型推导，可以大大简化我们的编程工作。

示例（`auto`配合模板使用）：

```c++
void func(vector<int> &tmp)
{
	for (auto i= tmp.begin(); i != tmp.end();++i)
    {
		cout << *i;
    }
    cout << endl;
}
```

上面的代码中无需明确指定`i`的类型，使用`auto`后编译器会自动推导`i`的类型，极大方便了代码编写。

### 推导规则

---

`auto`可以和引用、指针一起结合使用，还可以带上`const`和`volatile`修饰符。

通过一组例子来理解一下推导规则：

```c++
	int x = 0;
	auto * a = &x; 			//a→int *，auto被推导为int
	auto b = x; 			//b→int，auto被推导为int
	auto c = &x; 			//c→int &,atuo被推导为int
	auto *d = x; 			//error，无法推导auto类型，因为指针未被限定为常量
	auto &e = x; 			//e→const int&,auto被推导为 int
	auto &f = &x; 			// error, 未定义const int地址指向的内容
	const auto g = x; 		//g→const int,auto被推导为int
	const auto *h = x; 		//error，指针类型未定义
	const auto &i = x; 		//i→ const int，auto被推导为int
	const auto j = &x; 		//j→const int *,auto被推导为int
	const auto *k = &x; 	//k→const int *,auto被推导为int
    const auto &l = &x; 	//l→const int *，auto被推导为int，这里和未加const限定符的区别是，const限定了指针为常量
```

### 注意事项

---

- 使用`auto`定义的变量必须初始化。

  ```c++
  int main()
  {
      int a=10;
      auto b ;//编译报错，auto定义的变量必须初始化。
      b = 20;
  }
  ```

- 低版本编译器中，函数的参数列表不支持`auto`变量。

  示例：

  ```c++
  //VS2013，不支持以下写法，但高版本编译器支持
  void fun(auto a){//编译报错
      //...
  }
  ```

- `auto`变量不能作为自定义类型的成员变量。

  示例：

  ```c++
  struct ak
  {
  	int a;
  	auto b = 90;//编译报错，此处不允许使用auto
  };

- `auto`不能用于定义数组。

  示例：

  ```c++
  int main()
  {
  	auto sd[] = {0,1,2,3,4};//编译报错，auto类型不能出现在顶级数组类型中
  }
  ```

- 模板实例化参数不能是`auto`。

  示例：

  ```c++
  vector<auto>b = { 1 };//编译报错，此处不允许使用auto
  ```

- `auto`只能用于类的静态成员，不能用于类的非静态成员（普通成员），如果我们想推导非静态成员的类型，这个时候就必须使用`decltype`了。

## `decltype`自动类型推导

---

### 使用示例

---

`decltype`实际上有点像`auto`的反函数，`auto`可以让你声明一个变量，而`decltype`则可以从一个变量或表达式中得到其类型。

因为`auto`并不适用于所有的自动类型推导场景，在某些特殊情况下`auto`用起来非常不方便，甚至压根无法使用，所以`decltype`关键字也被引入到`C++11`中。

使用示例：

```c++
int main()
{
	int i;
	decltype(i) j = 0;
	cout << typeid(j).name() << endl;
    
	float a;
	double b;
	decltype(a + b) c;
	cout << typeid(c).name() <<endl;
    
	vector<int> tmp;
	decltype(tmp.begin()) k;
	for (k = tmp.begin(); k != tmp.end();++k)
    {
		//......
    }
}
```

输出结果：

```
int
double
class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<int> > >
```

对于匿名类型的变量，可以通过`decltype`获取类型后再次定义变量。

示例：

```c++
enum {Ok, Error } flag;//匿名类型的枚举变量flag，在C++11以前，后续代码中无法再次定义这个枚举变量
decltype(flag) flag2;//通过decltype获取flag的类型，再次定义这个匿名枚举类型的变量flag2
```

### 推导规则

---

当程使用`decltype(exp)`获取类型时，编译器将根据以下三条规则得出结果：

- 如果`exp`是一个不被括号`()`包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么`decltype(exp)`的类型就和`exp`一致。
- 如果`exp`是函数调用，那么`decltype(exp)`的类型就和函数返回值的类型一致。
- 如果`exp` 是一个左值，或者被括号`()`包围，那么`decltype(exp)`的类型就是`exp`的引用；假设`exp`的类型为`T`，那么`decltype(exp)`的类型就是`T&`

几个实际的例子：

- 示例1：

  ```c++
  #include <string>
  using namespace std;
  class Student
  {
  public:
      static int total;
      string name;
      int age;
      float scores;
  };
  int Student::total = 0;
  int  main()
  {
      int n = 0;
      const int &r = n;
      Student stu;
      decltype(n) a = n;  	//n 为 int 类型，a 被推导为 int 类型
      decltype(r) b = n;     	//r 为 const int& 类型, b 被推导为 const int& 类型
      decltype(Student::total) c = 0;  //total 为类 Student 的一个 int 类型的成员变量，c 被推导为 int 类型
      decltype(stu.name) url = "http://c.biancheng.net/cplus/";  //total 为类 Student 的一个 string 类型的成员变量，url被推导为 string 类型
      return 0;
  }
  ```

- 示例2：

  ```c++
  /*-------------函数声明--------------*/
  int& func_int_r(int, char);				//返回值为 int&
  int&& func_int_rr(void);				//返回值为 int&&
  int func_int(double);					//返回值为 int
  const int& fun_cint_r(int, int, int);	//返回值为 const int&
  const int&& func_cint_rr(void);			//返回值为 const int&&
  
  /*-------------decltype类型推导---------*/
  int n = 100;
  decltype(func_int_r(100, 'A')) a = n;  	//a 的类型为 int&
  decltype(func_int_rr()) b = 0;  		//b 的类型为 int&&
  decltype(func_int(10.5)) c = 0;   		//c 的类型为 int
  decltype(fun_cint_r(1,2,3))  x = n;    	//x 的类型为 const int &
  decltype(func_cint_rr()) y = 0;  		// y 的类型为 const int&&
  ```

- 示例3：

  ```c++
  using namespace std;
  class Base
  {
  public:
      int x;
  };
  int main()
  {
      const Base obj;
      
      //带有括号的表达式
      decltype(obj.x) a = 0;  	//obj.x 为类的成员访问表达式，符合推导规则一，a 的类型为 int
      decltype((obj.x)) b = a;  	//obj.x 带有括号，符合推导规则三，b 的类型为 int&。
      
      //加法表达式
      int n = 0, m = 0;
      decltype(n + m) c = 0;  	//n+m 得到一个右值，符合推导规则一，所以推导结果为 int
      decltype(n = n + m) d = c;  //n=n+m 得到一个左值，符号推导规则三，所以推导结果为 int&
      
      return 0;
  }
  ```

## 追踪返回类型

---

### 普通函数

---

```c++
int func1(int a, int b)
{
    return a+ b;
}
auto func2(int a, int b) -> int
{
    return a + b;
}
auto func3(int a, double b) -> decltype(a+b)
{
    return a+ b;
}
auto func4(auto a, auto b) -> decltype(a + b)
{
	return a + b;
}
```

对于上面3个函数，`func1`是传统写法，指定返回值类型，返回值始终是`int`；

`func2`使用`auto`推导返回值类型，但在参数列表后面指定了`auto`的类型为`int`；

`func3`使用`auto`推导返回值类型，并在参数列表后指定`auto`的类型为使用`decltype`推导出的结果。（返回值类型应该仍然为`double`，因为`int+double`发生隐式类型转换，类型仍应该为`double`。）

但对于`func4`，使用`auto`推导传入的参数，同时推导返回值类型，并指定`auto`的类型为使用`decltype`推导出的结果，这样子写更加智能和方便，无需明确指定返回值类型，避免了重载减少了重复代码。

示例：

```c++
#include <iostream>
using namespace std;

auto func(auto a, auto b) -> decltype(a + b)
{
	return a + b;
}

int main()
{
	auto a = func(10,90);
	cout << typeid(a).name() << endl;

	auto b = func(0.5,10);
	cout << typeid(b).name() << endl;

	float m= 0.123456789;

	auto c = func(m, 10);
	cout << typeid(c).name() << endl;

	system("pause>nul");
}
```

输出结果：

```
int
double
float
```

### 模板函数

---

对于模板函数，再无法准确判定返回值类型的情况下，也可以使用`auto`和`decltype`使编写代码更加方便和和智能。

示例：

```c++
#include <iostream>
using namespace std;

template<class T1, class T2>
auto func(T1 const& t1, const T2& t2) -> decltype(t1* t2)//右值引用，使用const修饰，前后两个位置都可以
{
	return t1 * t2;
}


int main()
{
	auto a= func(10,10);
	cout << "a=" << a << endl;
	cout << typeid(a).name() << endl;

	auto b = func(0.56, 10);
	cout << "b=" << b << endl;
	cout << typeid(b).name() << endl;

	system("pause>nul");
}
```

这里对于模板函数的传入参数无法准确判断其相乘后的返回值类型，因此使用`auto`和`decltype`来自动推导返回值。

在上面的例子中也可以省略参数列表后面的 `-> decltype(t1* t2)`。

输出结果：

```
a=100
int
b=5.6
double
```

### 其他示例

---

追踪返回类型声明的函数也会带给大家一些喜出望外的效果：

示例：

```c++
class OuterType
 {
     struct InnerType { int i; };
     InnerType GetInner();
     InnerType it;
 };

 auto OuterType::GetInner()->InnerType		 // 可以不写OuterType::InnerType
 {
     return it;
 }
```

简化函数的定义。常见于函数指针中。

示例：

```c++
#include <type_traits>
#include <iostream>
using namespace std;

 int (*(*pf()) ()) ()
 {
     return nullptr;
 }

 // 一个返回函数指针的函数（假设为func函数）
 // auto (*)()->int(*)();
 // 一个返回func函数的指针的函数
 // auto pf1()->auto (*)() -> int(*)();

 auto pf1() -> auto(*)() -> int (*)()
 {
     return nullptr;
 }

 int main()
 {
     cout << is_same<decltype(pf), decltype(pf1)>::value << endl;  // 1
 }
```

广泛应用在转发函数中。

示例：

```c++
#include <iostream>
using namespace std;

double foo(int a)
{
    return (double)a + 0.1;
}

int foo(double b)
{
    return (int)b;
}

template <class T>
auto Forward(T t) -> decltype(foo(t))
{
    return foo(t);
}

int main()
{
    cout << Forward(2) << endl;    // 2.1
    cout << Forward(0.5) << endl;  // 0
}
```

参考链接：[ C++11之追踪返回类型_追踪返回值类型_林夕07的博客-CSDN博客](https://blog.csdn.net/qq_45254369/article/details/127452583)

# 范围`for`循环

传统`for`循环：

```c++
int main()
{
    int a[]= { 1,2,3,4,5};
    int n = sizeof(a) / sizeof(*a);
    for (int i= 0; i<n; ++i)
    {
        int tmp = a[i];
        cout << tmp<< ", ";
	}
	cout << endl;
	
	system("pause");return 0;
}
```

C++11范围`for`循环：

```c++
int main()
{
    int a[]= { 1,2,3,4,5};
    
	for (int tmp : a)
    {
        cout << tmp << ",";
    }
    cout <<endl;
    
	system("pause");return 0;
}
```

上面两中方式的输出效果是一样的。

同时，范围`for`循环可以使用引用接受参数，达到修改的目的：

```c++
int main()
{
    int a[]= { 1,2,3,4,5};
    
	for (int& tmp : a)
    {
        tmp++;//数组每个值都加1
    }
    cout <<endl;
    
	system("pause");return 0;
}
```

注意！遍历对象必须是确定范围的，如果将一个数组作为参数传入一个函数，那么在函数体中是无法使用范围`for`循环遍历的，因为数组传入的是首地址，范围大小是不确定的。

范围`for`循环适用多种容器，包括`STL`中的大部分容器，使用范围`for`循环的代码更加简洁明了，可读性更高，使用起来也比传统`for`循环简单很多。

# 静态断言

`C++`提供了调试工具`assert()`，这是一个宏，用于在==运行阶段==对断言进行检查，如果条件为真，执行程序，否则调用`abort()`使程序中断。

`C++11`新增了关键字`static_assert`，可用于在==编译阶段==对断言进行测试。

语法：

```c++
static_assert(bool_constexpr,"message");
//bool_constexpr必须是常量表达式条件
//message是发生断言时提示的错误信息，只能是双引号包含的字符串文本
```

- 静态断言在编译时进行，断言在运行时进行。
- 因为在编译时不产生目标代码，所以静态断言基本不影响程序运行性能。
- 静态断言只能在32位机器上进行。
- 当`bool_constexpr`为假时，输出错误信息。
- 静态断言判断表达式涉及模板时，会等待模板实例化后再做判断。

静态断言的好处：

- 更早的报告错误，我们知道构建是早于运行的，更早的错误报告意味着开发成本的降低
- 减少运行时开销，静态断言是编译期检测的，减少了运行时开销

# 使用`nullptr`取代`NULL`

在某些情况下`int` 类型和`NULL`会产生二义性，因为实际上`NULL`等于`0`，大多数情况下编译器会将之看作整形，`NULL`只是是一个`#define NULL 0`的宏定义，可以同时赋值给指针和普通变量。当`NULL`作为参数给函数传参时，编译器会理解成`int`类型。

为了避免这种二义性的产生，在给指针置空时，更推荐使用`nullptr`。

`nullptr`是专门用于给指针置空的关键字，尽管表达式：`NULL==nullptr`的结果为真，但`nullptr`只能给指针赋值。

总之，在给指针置空时，推荐使用`nullptr`而不是`NULL`。

# 强类型枚举

## 传统枚举的局限性

---

- 传统枚举方式枚举成员的作用域在同一作用域下是共享的，无法同时定义两个含有相同名称的枚举成员。

  以下情况会报错：

  ```c++
  int main()
  {
      enum Status1 {Ok, Error};
      enum Status2 {Ok, Error};
  }
  ```

  上述代码编译会报错，因为在`main`函数作用域下，传统枚举成员的作用域是共享的，会发生重定义错误。

  当然可以通过多种方式解决这个问题，但会让代码变得繁琐和冗余，可读性下降。

- 传统枚举不能指定枚举成员类型，默认指定为`int`整形，因此在作为参数传参等场景下会发生隐式类型转换，导致精度丢失、数据丢失等问题。

详见：[C++ 你所不知道的枚举类型（ENUM）](https://www.bilibili.com/video/BV19T411T71n?vd_source=03da7de0e80f9ff60fdeca7b512ba3f5)

## `C++11`强类型枚举

---

为了解决上述问题，C++11引入了强类型枚举，解决了枚举成员作用域共享和枚举成员类型不能指定的问题。

语法：

- 在`enum`和枚举名称之间加上`class`或`struct`修饰，这两种修饰方式无区别。

- 在枚举名称后加上“`:`”和数据类型，可以指定该枚举的枚举成员为冒号后的数据类型。

- 若不指定枚举成员的数据类型，则仍然默认为`int`类型。

- 如果不对枚举成员赋初始值，则按传统枚举默认赋值的规则给枚举成员进行赋值。

- 指定的枚举成员类型其基础类型必须是整形。如：`char`、`long`、`long long`、`unsigned int`等。但`float`、`double`就不可以，因为其基础类型为浮点型。

  ```c++
  enum class Status { Ok=1, Error };//默认 int 类型，默认值：Ok=1、Error=2（Ok+1）
  enum struct Status2 { Ok=1, Error=9, No};//默认 int 类型，并赋值O k=1、Error=9，No没有赋值，则No=10（Error+1）
  
  enum struct Status3 : char { Ok, Error='a', No};
  //指定 Status3 的枚举成员为 char 型，并给Error赋值为'a'，Ok和No没有赋值，则Ok=0（ASCLL码值对应NULL），NO=98（即：a的ASCLL码+1，对应字符为b）
  ```

- 获取枚举成员必须要在枚举名称之前加上作用域

- 获取到的枚举成员类型为该枚举类型，而非指定的枚举成员类型，但其记录的值不变，使用时需要将枚举成员进行强转。

  ```c++
  enum class test :char
  {
      ok='o', no='n', yes='y'
  };
  
  enum class test resut;//定义枚举变量resut，class可省略，或enum和class同时省略
  /*下面两种定义方式也可以*/
  enum test resut1;
  test resut2;
  
  resut=test::yes;//给枚举变量赋初值，只能是枚举中的枚举成员，但枚举成员名前必须加上作用域，因为强类型枚举的枚举成员作用域是不共享的
  
  //cout<< resut <<endl;//错误，因为resut实际上是 test 枚举类型，需要强转成 char 型才能获取期望的结果
  cout << (char)resut << endl;//C风格强转
  cout << static_cast<char>(test::no) << endl; //推荐使用C++的类型转换
  ```

  输出结果：

  ```
  y
  n
  ```

除了上述提到的一些优点，指定数据类型还可以突破原本`int`类型的最大长度限制，如：指定枚举成员类型为`unsigned long long`

```c++
    enum class test :unsigned long long
    {
        ok, no=9999999999999999999//已经远远超过 int 所能表示的最大值
    };
    cout << static_cast<unsigned long long>(test::no) << endl;
```

输出结果：

```
9999999999999999999
```

## 前置声明的写法

---

对于前置声明，以下写法将被接受：

```c++
enmu class Clolor:char;            		//前置声明枚举类
void Foo(Color*p);                     	//前置声明的使用
//....................
enum class Color:char{RED, GREEN, BLACK, WHITE};      //前置声明的定义
```

分文件编写：

在头文件中：

```cpp
enum class LogLevel;//前置声明，并默认成员类型为int

class Logger
{
    // ........
    
private:
    void logging(enum class LogLevel level, String message);//enum class可省略
};

```

在源文件中：

```c++
#include "头文件"

//枚举的实现
enum class LogLevel
{
    // ........
};

// ........
```

## 参考

[C++干货系列——"强"枚举有多强](https://zhuanlan.zhihu.com/p/164634712)
[C++ 之 enum 枚举量声明、定义、使用与强类型枚举详解](https://www.runoob.com/w3cnote/cpp-enums-intro-and-strongly-typed.html)
[C++11强类型枚举](https://blog.csdn.net/daoming1112/article/details/54932881)
推荐：[明解 C++ Primer：19.3枚举类型](https://www.bilibili.com/video/BV1da411K7Kp?vd_source=03da7de0e80f9ff60fdeca7b512ba3f5)

# `constexpr`修饰的变量和表达式

## 概念和使用方法

---

`constexpr`修饰的变量和表达式称为常量表达式。

常量表达式主要是允许一些计算发生在编译时，即发生在代码编译而不是运行的时候。

这是很大的优化：假如有些事情可以在编译时做，它将只做一次，而不是每次程序运行时都计算。

关键字：`constexpr`

用法：使用`constexpr`修饰函数、表达式或变量
示例：

```c++
#include <iostream>
using namespace std;

int GetNum ()
{
	return 3;
}

const int GetNum2 ()
{
	return 3;
}

constexpr int GetNum3 ()//常量表达式，发生在编译阶段
{
	return 3;
}

int main ()
{

    // enum {el = GetNum() , e2};	//编译错误	//枚举成员初始化，必须是整型常量
    // enum {el = GetNum2() , e2}; 	//加上const，同样编译错误，因为GetNum2在运行时才调用
    
    enum {e1=GetNum3() , e2}; //正确，编译通过，因为 GetNum3() 在编译阶段发生调用
    
    constexpr int tmp = GetNum3();//全部发生在编译阶段
    enum {al = tmp, a2};//正确，编译通过
    
    
	return 0;
}
```

## `constexpr`修饰函数的限制

---

只对于`C++11`标准，有以下限制：

- 函数中只能有一个`return`的语句，不允许有其他除了`ruturn`以外的语句（有少数特例，允许包括：`using`指令、静态断言、`typedef`）

- 函数必须返回值（不能是无返回值的`void`函数)

- 在使用前必须已有定义

- `return`返回语句表达式中不能使用==非常量==表达式的函数、全局数据，且必须是一个常量表达式

在`C++11`以后的标准中（截至`C++20`）上述所有限制都不成立，使用起来和普通函数没有什么区别，对于特殊场景编译器会自动选择并优化或提示错误（参考上述示例的使用场景），这里不做过多讲述。

## `constexpr`修饰类的成员函数

---

在`C++11`以后的标准中（截至`C++20`）上述所有限制都不成立，使用起来和普通成员函数没有什么区别，对于特殊场景编译器会自动选择并优化，这里不做过多讲述。

# 用户自定义字面量

复制自文章：[C++11新特性2 - 用户定义字面量](https://zhuanlan.zhihu.com/p/111369693)，并稍加增改。

## C++中的字面量

---

`C++` 自带4种字面量：

- 整形 `123`
- 浮点型 `12.3`
- 字符 `'1'`
- 字符串 `"123"`

字面量又可添加后缀来表明具体类型：

- 无符号整形(`unsigned int`): `123u`
- 长整形(`long`): `123l`

在 `C++03` 中，我们可以定义一个浮点数height

```cpp
double height = 3.4
```

那么，痛点来了，此处的` height `的单位是什么呢？米？厘米？又或是英尺？

在面对此类问题时，如果我们能编写如下代码，事情就会简单许多:

```cpp
height = 3cm;

// ratio = (3 * 10) / 2
ratio = 3cm / 2mm;
```

## 用户自定义字面量后缀

---

```cpp
long double operator"" _cm(long double x) 
{
  return x * 10;
}

long double operator"" _m(long double x) 
{
  return x * 1000;
}

long double operator"" _mm(long double x) 
{
  return x;
}

// height = 30.0
auto height = 3.0_cm; 

// length = 1230.0
auto length = 1.23_m;
```

如果使用这种写法，`_cm`, `_m`, `_mm` 等函数将在运行时被调用，如果希望在编译时就调用字面量后缀函数，则需要把函数定义为 `constexpr`，例如

```cpp
constexpr long double operator"" _cm(long double x) 
{
  return x * 10;
}
```

更进一步，我们甚至可以

```cpp
// 注意，如果这里要定义函数为 constexpr
// 编译时需要使用 c++14 标准(-std=c++14)
int operator"" _bin(const char* s, size_t n) //只需给第一个参数传参，第二个参数自动推算，测第一个参数的长度，给第二个参数赋值
{
  int ret = 0;
  for (int i = 0; i < n; i++)
  {
    ret = (ret << 1) | (s[i] - '0');
  }
  return ret;
}

int num = "110"_bin; // num = 6
```

## **自定义字面量的限制**

---

`C++11 `只允许字面量后缀函数的参数为以下类型，即整数，浮点以及字符串：

- `unsigned long long`
- `long double`
- `char const*`
- `char const*, std::size_t`
- `wchar_t const*, std::size_t`
- `char16_t const*, std::size_t`
- `char32_t const*, std::size_t`

返回值则无类型限制

参数中有`size_t`时，只需给第一个参数传参，第二个参数`size_t`自动推算。

## 使用场景示例

```c++
#include <iostream>
using namespace std;

int operator""_cm(const char* str)
{
    string num(str);
    return atoi(num.c_str());;
}

int main()
{
    auto hight = 100_cm;
    int weight = 200_cm;
    cout << "size = " << hight * weight  << endl;
    return 0;
}
```

输出结果：

```
size = 20000
```

# 右值引用

## 左值和右值的概念

在 C++ 或者 C 语言中，一个表达式（可以是字面量、变量、对象、函数的返回值等）根据其使用场景不同，分为左值表达式和右值表达式。

左值指既能够出现在等号左边，也能出现在等号右边的变量；右值则是只能出现在等号右边的变量。

- 左值是可寻址的变量，有持久性；
- 右值一般是不可寻址的常量，或在表达式求值过程中创建的无名临时对象，短暂性的。

左值和右值主要的区别之一是左值可以被修改，而右值不能。

```c++
int a; // a 为左值
a = 3; // 3 为右值
```

```c++
int func()
{
    return a;
}
int mian()
{
    int a = func();//a为右值，func的返回值是右值，无法直接对func的返回值进行修改
}
```

## 左值引用和右值引用

### 左值引用

详见文件：[C++基础.md](.\C++基础.md)——引用篇，详解

### 右值引用

`C++98/03`标准中就有引用，使用 `&` 表示。但此种引用方式有一个缺陷，即正常情况下只能操作`C++`中的左值，无法对右值添加引用。

示例：

```c++
int num = 10;
int &b = num; //正确
int &c = 10; //错误
```

如上所示，编译器允许我们为`num`左值建立一个引用，但不可以为`10`这个右值建立引用。因此，`C++98/03`标准中的引用又称为左值引用。

注意，虽然`C++98/03`标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如：

```c++
int num = 10;
const int &b = num;
const int &c = 10;
```

右值往往是没有名称的，因此要使用它只能借助引用的方式。

这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。

`C++11`标准新引入了另一种引用方式，称为右值引用，用 `&&`表示。

`C++`标准委员会在选定右值引用符号时，既希望能选用现有`C++`内部已有的符号，还不能与`C++ 98 /03` 标准产生冲突，最终选定了 2 个 `&` 表示右值引用。

需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，比如：

```c++
int num = 10;
int && a = num;  //错误，左值不能被右值引用
int && a = 10;
```

和常量左值引用不同的是，右值引用还可以对右值进行修改。例如：

```c++
int && a = 10;
a = 100;
cout << a << endl;
```

程序输出结果为 `100`。

`C++`语法上是支持定义常量右值引用的，例如：

```c++
const int&& a = 10;
```

但这种定义出来的右值引用并无实际用处。

一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限

其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。

<table>
<caption>
C++左值引用和右值引用</caption>
<tbody>
<tr>
<th colspan="1" rowspan="2">
引用类型</th>
<th colspan="4" rowspan="1">
可以引用的值类型</th>
<th colspan="1" rowspan="2">
使用场景</th>
</tr>
<tr>
<th>
非常量左值</th>
<th>
常量左值</th>
<th>
非常量右值</th>
<th>
常量右值</th>
</tr>
<tr>
<td>
非常量左值引用</td>
<td>
Y</td>
<td>
N</td>
<td>
N</td>
<td>
N</td>
<td>
无</td>
</tr>
<tr>
<td>
常量左值引用</td>
<td>
Y</td>
<td>
Y</td>
<td>
Y</td>
<td>
Y</td>
<td>
常用于类中构建拷贝构造函数</td>
</tr>
<tr>
<td>
非常量右值引用</td>
<td>
N</td>
<td>
N</td>
<td>
Y</td>
<td>
N</td>
<td>
移动语义、完美转发</td>
</tr>
<tr>
<td>
常量右值引用</td>
<td>
N</td>
<td>
N</td>
<td>
Y</td>
<td>
Y</td>
<td>
无实际用途</td>
</tr>
</tbody>
</table>

表中，Y 表示支持，N 表示不支持。

`C++11`标准中对右值做了更细致的划分，分别称为纯右值（Pure value，简称 pvalue）和将亡值（eXpiring value，简称 xvalue ）。

其中纯右值就是`C++98/03`标准中的右值，而将亡值则指的是和右值引用相关的表达式（比如某函数返回的`T &&`类型的表达式）。

# 移动语义

## 为什么需要移动语义

如果一个对象中有堆区资源，需要编写拷贝构造函数和赋值函数，实现深拷贝。

深拷贝把对象中的堆区资源复制了一份，如果源对象（被拷贝的对象）是临时对象，拷贝完就没什么用了，这样会造成没有意义的资源申请和释放操作。

同时临时对象的维护（创建和销毁）对性能有严重影响。

如果能够直接使用源对象拥有的资源，可以节省资源申请和释放的时间。

C++11新增加的移动语义就能够做到这一点。

实现移动语义要增加两个函数：移动构造函数和移动赋值函数。

转移语义可以将资源（堆，系统对象等）从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高C++应用程序的性能。

右值引用就是用来支持转移语义的。

转移语义是和拷贝语义相对的，可以类比文件的剪切与拷贝，当我们将文件从一个目录拷贝到另一个目录时，速度比剪切慢很多。

通过转移语义，临时对象中的资源能够转移其它的对象里。

## 转移构造函数

移动构造函数是一种特殊的构造函数，用于在对象之间进行资源的移动而不是复制。

移动构造函数通常用于以下情况：

- 当使用右值引用（使用双&&符号）绑定到一个临时对象时，移动构造函数将被调用。
- 当使用`std::move`函数将一个对象强制转换为右值引用时，移动构造函数将被调用。

移动构造函数的目的是将资源（例如堆分配的内存、文件句柄等）从一个对象转移到另一个对象，而不是复制这些资源。

通过移动而不是复制资源，可以显著提高性能，避免不必要的内存分配和复制操作。

语法：

移动构造函数的语法与普通构造函数的语法非常相似，只是在参数列表前加上了双&&符号来表示右值引用。

```cpp
ClassName(ClassName&& other);  // 移动构造函数
```

在移动构造函数中，参数`other`是一个右值引用，表示要移动资源的对象。在函数体内，你可以使用移动操作符`std::move`来将资源从`other`对象转移给当前对象。

移动构造函数通常会将源对象的成员指针设置为`nullptr`，以避免在析构函数中重复释放资源。

这是因为资源的所有权已经转移到了目标对象。

移动构造函数通常也可以声明为`noexcept`，以表明它不会抛出异常。这对于某些情况下的优化和语义保证很重要。

下面是一个完整的示例，展示了移动构造函数的语法和用法：

```cpp
#include <iostream>

class MyClass 
{
public:
    int* data;

    // 默认构造函数
    MyClass() : data(nullptr)
    {
        std::cout << "Default constructor called." << std::endl;
    }

    // 移动构造函数
    MyClass(MyClass&& other) noexcept : data(nullptr) 
    {
        std::cout << "Move constructor called." << std::endl;
        data = other.data;
        other.data = nullptr;
    }

    // 析构函数
    ~MyClass() 
    {
        if (data != nullptr) 
        {
            delete data;
        }
    }
};

int main() 
{
    MyClass source;
    source.data = new int(42);

    MyClass destination(std::move(source));

    std::cout << "source.data: " << source.data << std::endl;
    std::cout << "destination.data: " << destination.data << std::endl;

    return 0;
}
```

在上面的示例中，我们定义了一个`MyClass`类，包含了一个指针成员变量`data`。我们使用移动构造函数将资源从`source`对象移动到`destination`对象。

在移动构造函数的参数列表中，使用了`ClassName&&`的形式来表示右值引用。

需要注意，一旦资源被移动到目标对象，源对象的资源将不再有效。

因此，应该小心使用移动构造函数，确保正确处理资源所有权和对象的状态。

## 转移赋值函数







和拷贝构造函数类似，有几点需要注意：

- 参数（右值）的符号必须是右值引用符号，即“&&”。
- 参数（右值）不可以是常量，因为我们需要修改右值。
- 参数(右值)的资源链接和标记必须修改，否则，右值的析构函数就会释放资源，转移到新对象的资源也就无效了。

有了右值引用和转移语义，我们在设计和实现类时，对于需要动态申请大量资源的类，应该设计转移构造函数和转移赋值函数，以提高应用程序的效率。





## `std::move`

对于一个左值，会调用拷贝构造函数，但是有些左值是局部变量，生命周期也很短，能不能也移动而不是拷贝呢?

C++11为了解决这个问题，提供了`std:move()`方法来将左值转义为右值，从而方便使用移动语义。

它其实就是告诉编译器，虽然我是一个左值，但不要对我用拷贝构造函数，用移动构造函数。

左值对象被转移资源后，不会立刻析构，只有在离开自己的作用域的时候才会析构，如果继续使用左值中的资源，可能会发生意想不到的错误。

如果没有提供移动构造/赋值函数，只提供了拷贝构造/赋值函数，编译器找不到移动构造/赋值函数就去寻找拷贝构造/赋值函数。

C++11中的所有容器都实现了移动语义，避免对含有资源的对象发生无谓的拷贝。

移动语义对于拥有资源（如内存、文件句柄)的对象有效，如果是基本类型，使用移动语义没有意义。

示例：

```c++
int a;
int &&r1 = a;//编译失败
int &&r2 = std:move(a);//编译通过
```

# 完美转发

完美转发适用于这样的场景：

需要将一组参数原封不动的传递给另一个函数。

“原封不动”不仅仅是参数的值不变，在C++中，除了参数值之外，还有一下两组属性：

左值/右值和 const/non-const。

完美转发就是在参数传递过程中，所有这些属性和参数值都不能改变，同时，而不产生额外的开销，就好像转发者不存在一样。

在泛型函数中，这样的需求非常普遍。















# 类型转换

## `const_cast`

---

`const_cast`是`C++`中的一个类型转换运算符，用于将`const`和`volatile`限定符从指针或引用类型中移除。

它的语法如下：

```c++
const_cast<new_type>(expression)
```

其中，`new_type`是要转换成的类型，`expression`是要转换的表达式。

举个例子，假设有一个`const int`类型的变量，我们想要修改它的值，可以使用`const_cast`将其转换成`int`类型，然后进行修改。

示例代码如下：

```c++
const int a = 10;
int& b = const_cast<int&>(a);
b = 20;
std::cout << a << std::endl; // 输出10
std::cout << b << std::endl; // 输出20
```

需要注意的是，使用`const_cast`进行类型转换可能会导致未定义行为，因为它可以打破`const`限定符的保护。

因此，在使用`const_cast`时需要谨慎，确保不会对原始对象造成损害。

## `reinterpret_cast`

---

`reinterpret_cast`是`C++`中的一个类型转换运算符，用于进行底层的类型转换。这是一个很危险的转换，编译器不会做任何类型安全的检查。

它可以将一个指针或引用转换为任何其他类型的指针或引用，甚至可以将一个指针转换为一个整数类型。

它的语法如下：

```C++
reinterpret_cast<new_type>(expression)
```

其中，`new_type`是要转换成的类型，`expression`是要转换的表达式。

举个例子，假设有一个`int`类型的变量，我们想要将它的值转换成一个指针，可以使用`reinterpret_cast`。

示例代码如下：

```C++
int a = 10;
int* p = reinterpret_cast<int*>(a);
*p = 20;
std::cout << a << std::endl; // 输出20
std::cout << *p << std::endl; // 输出20
```

需要注意的是，使用`reinterpret_cast`进行类型转换可能会导致未定义行为，因为它可以将一个指针转换为一个不相关的类型。

因此，在使用`reinterpret_cast`时需要谨慎，确保转换的类型是合法的。

## `dynamic_cast`

---

`dynamic_cast`是`C++`中的一个类型转换运算符，用于在运行时进行类型转换。

它主要用于将父类指针或引用转换为子类指针或引用（这种转换也称下行转换），或者将`void`指针转换为其他类型的指针。

它的语法如下：

```c++
dynamic_cast<new_type>(expression)
```

其中，`new_type`是要转换成的类型，`expression`是要转换的表达式。

举个例子，假设有一个基类`Animal`和两个派生类`Cat`和`Dog`，我们想要将一个`Animal`指针转换成`Cat`指针，可以使用`dynamic_cast`。

示例代码如下：

```C++
class Animal 
{
public:
    virtual void makeSound() {}
};

class Cat : public Animal 
{
public:
    void makeSound() override
    {
        std::cout << "Meow!" << std::endl;
    }
};

class Dog : public Animal 
{
public:
    void makeSound() override 
    {
        std::cout << "Woof!" << std::endl;
    }
};

int main() 
{
    Animal* animal = new Cat();
    Cat* cat = dynamic_cast<Cat*>(animal);
    if (cat) 
    {
        cat->makeSound(); // 输出Meow!
    }
    delete animal;
    return 0;
}
```

使用`dynamic_cast`进行类型转换时，如果转换失败，会返回一个空指针或引用。

因此，在使用`dynamic_cast`时需要进行判断，确保转换成功。

## 上行转换和下行转换

---

在C++中，上行转换（upcasting）和下行转换（downcasting）是与继承和多态相关的概念。

上行转换是指将子类的指针或引用隐式地转换为父类的指针或引用。

这种转换是安全的，因为子类对象包含了父类的成员，因此可以通过父类的接口来访问子类的成员。

例如：

```cpp
class Animal 
{
public:
    virtual void eat() 
     {
        cout << "Animal is eating." << endl;
    }
};

class Dog : public Animal 
{
public:
    void eat() override 
    {
        cout << "Dog is eating." << endl;
    }

    void bark() 
    {
        cout << "Dog is barking." << endl;
    }
};

int main() 
{
    Dog dog;
    Animal* animalPtr = &dog;  // 上行转换
    animalPtr->eat();  // 调用的是子类的 eat() 函数

    return 0;
}
```

在上面的示例中，`Dog` 类是 `Animal` 类的子类。通过将 `Dog` 类的对象的指针赋值给 `Animal` 类的指针，发生了上行转换。

即 `animalPtr` 指向的是 `Dog` 类的对象，但只能通过 `Animal` 类的接口来访问。



下行转换是指将父类的指针或引用显式地转换为子类的指针或引用。这种转换需要使用 `dynamic_cast` 运算符（下一篇将讲到），并且在运行时进行类型检查，因为并非所有父类的指针或引用都可以转换为子类类型。

例如：

```cpp
class Animal 
{
public:
    virtual void eat() 
     {
        cout << "Animal is eating." << endl;
    }
};

class Dog : public Animal 
{
public:
    void eat() override 
    {
        cout << "Dog is eating." << endl;
    }

    void bark() 
    {
        cout << "Dog is barking." << endl;
    }
};

int main() 
{
    Animal animal;
    Animal* animalPtr = &animal;
    Dog* dogPtr = dynamic_cast<Dog*>(animalPtr);  // 下行转换，这段代码的作用是将父类指针animalPtr转换为子类指针dogPtr

    if (dogPtr != nullptr) 
    {
        dogPtr->bark();  // 通过子类指针访问子类的成员
    }
    else 
    {
        cout << "Downcasting failed." << endl;
    }

    return 0;
}
```

在上面的示例中，`dynamic_cast` 运算符将 `Animal` 类的指针 `animalPtr` 转换为 `Dog` 类的指针 `dogPtr`。

由于 `animalPtr` 实际指向的是 `Animal` 类的对象，而不是 `Dog` 类的对象，所以转换失败，`dogPtr` 的值为 `nullptr`。

输出结果：

```c++
Downcasting failed.
```

因此，建议在进行下行转换之前，先使用 `dynamic_cast` 运算符进行类型检查，以确保转换的安全性。

如果不使用 `dynamic_cast` 运算符进行类型检查，虽然可以转换成功，但是当调用子类成员时程序就可能会发生错误。

上行转换是安全的，因为子类对象是父类对象的扩展，可以通过父类接口访问子类的成员。

下行转换需要进行类型检查，因为父类对象的指针或引用并不总是指向子类对象。



如果使用C风格的强制类型转换，将父类指针或引用直接转换为子类指针或引用，而不使用`dynamic_cast`进行类型检查，可能会导致以下问题：

- 未进行类型检查：

  C风格的强制类型转换不会进行类型检查，因此无法确保父类指针或引用指向的对象的确是子类对象。如果父类指针或引用并不指向子类对象，而你进行了转换，将会导致不可预测的行为和潜在的错误。

- 切割对象：

  如果你使用强制类型转换将父类指针或引用转换为子类指针或引用，而父类对象中含有子类特有的成员或虚函数，这些子类特有的内容将会被切割掉，导致在转换后无法访问这些成员或调用这些虚函数。

- 安全性问题：

  由于没有进行类型检查，使用强制类型转换可能会破坏C++的类型系统和继承体系的安全性。这可能导致程序在运行时产生未定义行为、内存访问错误或崩溃。

示例：

```c++
#include <iostream>
using namespace std;
class Animal
{
public:
    
    virtual void eat()
    {
        cout << "Animal is eating." << endl;
    }
};

class Dog : public Animal
{
public:
    void eat() override
    {
        cout << "Dog is eating." << endl;
    }

    void bark()
    {
        cout << "Dog is barking." << endl;
    }
    string name = "ggbom";
};

int main()
{
    Dog* dogPtr =(Dog*) new Animal*; 
    cout <<"dog's name:" << dogPtr->name << endl;
    cout << "dog's name length:" << dogPtr->name.length() << endl;
    return 0;
}
```

上述这段代码运行的结果是不确定的，有时会报错提示读取写入内存冲突，有时会使程序直接崩溃，有时则能打印出`dog's name:` 和`dog's name length:0`，但是`dogPtr->name`的部分是空白，有时则只打印`dog's name:`，然后程序直接结束。



因此，只在C++中使用`dynamic_cast`进行下行转换，以确保类型安全性和正确性。

`dynamic_cast`会在运行时进行类型检查，只有在父类指针或引用确实指向子类对象时才会返回有效的子类指针或引用。。

## `static_cast`

---

`static_cast`是`C++`中的一个类型转换运算符，用于进行静态类型转换。

用于一些基本类型的转换和有继承关系的父类和子类指针或引用间的转换。

`static_cast`不会产生动态转换的类型安全检查的开销，由程序员来确保转换是安全的。

它的语法如下：

```C++
static_cast<new_type>(expression)
```

其中，`new_type`是要转换成的类型，`expression`是要转换的表达式。

举个例子，假设有一个int类型的变量，我们想要将它的值转换成一个`double`类型，可以使用`static_cast`。

示例代码如下：

```C++
int a = 10;
double b = static_cast<double>(a);
std::cout << b << std::endl; // 输出10.0
```

需要注意的是，使用`static_cast`进行类型转换时，如果转换不安全，可能会导致未定义行为。

因此，在使用`static_cast`时需要谨慎，确保转换的类型是安全的。

# lambda表达式

lambda表达式是一种用于创建匿名函数的简洁语法。

lambda表达式可以用作函数对象，并且可以捕获上下文中的变量。

下面是一个使用lambda表达式的示例：

```cpp
#include <iostream>
#include <functional>

int main() 
{
    int factor = 2;
    std::function<int(int)> func = [factor](int x) { return factor * x; };
    std::cout << func(3) << std::endl;  // 输出：6
    return 0;
}
```

在上面的示例中，lambda表达式`[factor](int x) { return factor * x; }`定义了一个函数对象，它接受一个`int`参数并返回`factor * x`的结果。

在lambda表达式中，我们通过方括号`[]`捕获了外部变量`factor`，以便在lambda表达式中使用。

lambda表达式的一般形式是：

- `[捕获列表](参数列表) -> 返回类型 { 函数体 }`
- 其中捕获列表指定需要捕获的外部变量，参数列表指定函数的参数，返回类型指定函数的返回类型，函数体则是函数的实现。

lambda表达式还支持各种功能，如可变捕获（允许修改被捕获的变量）、自动类型推导、多行函数体等。

它们非常灵活，并且通常与算法函数（如`std::for_each`、`std::transform`等）一起使用，用于对容器中的元素进行处理。

其中`参数列表`、在函数无参时可以省略，`->`、`返回值类型`也可以省略，省略后将由编译器自动推导。`[捕获列表]`和`{函数体}`不可以省略，因此最简单的lambda表达式的形式是这样的：`[]{};`，解释：这是一个匿名函数对象，无参、无返回值、函数体内部为空实现，捕获列表为空。



关于捕获列表：

捕获列表用于指定Lambda表达式中要捕获的外部变量。

将lambda表达式理解成函数，如果需要在函数体内部使用到函数体外的变量和表达式，那么就需要在捕获列表中指明需要用到的表达式。

可以使用引用捕获或值捕获，使用引用捕获时当在函数体内部对捕获的变量进行了修改，那么外部变量原来的值也会发生改变，值捕获相当于拷贝了一份，函数体内部的操作不会影响原来的值，同样使用值捕获也不能在函数体内部对捕获的变量进行修改。

下面是捕获列表的几种常见写法：

1. `[&]`：使用引用捕获方式，表示捕获外部作用域中的所有变量（按引用方式）。

2. `[=]`：使用直接捕获方式，表示捕获外部作用域中的所有变量（按值方式）。

3. `[x, &y]`：捕获外部作用域中的变量`x`（按值方式）和变量`y`（按引用方式）。

4. `[&z, this]`：捕获外部作用域中的变量`z`（按引用方式）和当前对象指针`this`（按值方式）。

5. `[]`：不捕获任何外部变量。

在捕获列表中，`&`表示按引用捕获，`=`表示按值捕获。

捕获列表中的变量名可以是当前作用域中的任何变量，包括函数参数、局部变量等。使用逗号将不同的变量进行分隔。

示例代码1：

```cpp
#include <iostream>

int main()
{
    int x = 5;
    int y = 10;
    int z = 15;

    // 按引用捕获x和y，按值捕获z
    auto lambda1 = [&x, &y, z]() 
    {
        x++;
        y++;
        // z++; // 错误，无法修改被值捕获的变量
        std::cout << "x: " << x << std::endl;
        std::cout << "y: " << y << std::endl;
        std::cout << "z: " << z << std::endl;
    };

    // 按值捕获x和y，不捕获其他变量
    auto lambda2 = [=]() 
    {
        // x++; // 错误，无法修改被值捕获的变量
        // y++; // 错误，无法修改被值捕获的变量
        std::cout << "x: " << x << std::endl;
        std::cout << "y: " << y << std::endl;
    };

    lambda1(); // 输出：x: 6, y: 11, z: 15
    lambda2(); // 输出：x: 5, y: 10

    return 0;
}
```

在这个示例中，我们定义了两个Lambda表达式：`lambda1`和`lambda2`。`lambda1`的捕获列表使用了引用捕获和值捕获的组合，它按引用捕获了变量`x`和`y`，按值捕获了变量`z`。`lambda2`的捕获列表使用了纯值捕获，它按值捕获了变量`x`和`y`。你可以尝试运行这段代码，观察输出结果，以加深对捕获列表的理解。

需要注意的是，捕获列表中的变量名必须是在Lambda表达式的外部作用域中可见的。

对于捕获的变量，如果在Lambda表达式内部对其进行修改，使用引用捕获的变量会影响到外部作用域中的原始变量，而使用直接捕获的变量只会修改Lambda表达式内部的副本，不会影响外部作用域中的原始变量。

示例代码2：

```c++
#include <iostream>

int main() 
{
    int x = 5;
    int y = 10;

    // 引用捕获示例
    auto lambdaRef = [&]() 
    {
        x++;
        std::cout << "x: " << x << std::endl;
        std::cout << "y: " << y << std::endl;
    };

    // 直接捕获示例
    auto lambdaCopy = [=]() 
    {
        // y++; // 错误，无法修改被值捕获的变量
        std::cout << "x: " << x << std::endl;
        std::cout << "y: " << y << std::endl;
    };

    lambdaRef();  // 输出：x: 6, y: 10
    lambdaCopy(); // 输出：x: 5, y: 10

    std::cout << "x: " << x << std::endl;
    std::cout << "y: " << y << std::endl;

    return 0;
}

```









# `std::function`

## 概述

当你在C++中需要将函数作为参数传递或者将其存储在容器中时，`std::function`和lambda表达式是两个非常有用的工具。

它们都是C++11引入的特性，可以用于创建可调用对象。

`std::function`是一个通用的函数封装器，可以用来存储、复制和调用任何可调用对象（函数指针、函数对象、成员函数指针等）。

使用`std::function`，你可以将函数包装在一个类型安全的容器中，并将其传递给其他函数或算法进行处理。

下面是一个使用`std::function`的简单示例：

```cpp
#include <iostream>
#include <functional>

int add(int a, int b) 
{
    return a + b;
}

int main()
{
    std::function<int(int, int)> func = add;
    std::cout << func(3, 4) << std::endl;  // 输出：7
    return 0;
}
```

在上面的示例中，`std::function<int(int, int)>`表示一个可调用对象，它接受两个`int`参数并返回一个`int`值。

通过将`add`函数分配给`func`，我们可以通过`func(3, 4)`调用`add`函数。



在C++中，`std::function`是一个通用的函数封装器，它可以存储、复制和调用任何可调用对象，例如函数、函数指针、Lambda 表达式、成员函数指针等。`std::function`提供了一种将函数对象与其参数类型和返回类型解耦的方式，使得函数对象可以像普通函数一样传递和使用。

`std::function`定义在头文件 `<functional>` 中，它是一个类模板，其基本语法如下：

```cpp
std::function<返回类型(参数类型)> func;
```

其中，`返回类型`是函数对象的返回类型，而`参数类型`是函数对象的参数类型。下面来详细讲解`std::function`的一些特性和用法：

## `std::function`的创建和调用

要创建一个`std::function`对象，可以通过函数指针、函数对象、Lambda 表达式等来进行初始化，

可以像调用普通函数一样，使用括号运算符来调用`std::function`对象。

如下所示：

```cpp
#include <functional>
#include <iostream>

// 函数对象
struct Functor 
{
    int operator()(int x, int y) 
    {
        return x + y;
    }
};

//普通函数
int add(int x, int y) 
{
    return x + y;
}

int main() 
{
    std::function<int(int, int)> func1 = add;
    std::function<int(int, int)> func2 = Functor();
    std::function<int(int, int)> func3 = [](int x, int y) { return x + y; };
    
    std::cout << func1(3, 5) << std::endl; // Output: 8
    std::cout << func2(3, 5) << std::endl; // Output: 8
    std::cout << func3(3, 5) << std::endl; // Output: 8

    return 0;
}
```

## 空`std::function`

如果一个`std::function`没有与之关联的可调用对象，那么它被称为空的。

调用一个空的`std::function`会导致`std::bad_function_call`异常的抛出。

```cpp
#include <functional>
#include <iostream>

int main() 
{
    std::function<int(int, int)> func;

    try 
    {
        int result = func(3, 5); // 调用空的std::function，会抛出std::bad_function_call异常
        std::cout << result << std::endl;
    } 
    catch (const std::bad_function_call& ex) 
    {
        std::cout << "Exception caught: " << ex.what() << std::endl; // Output: Exception caught: bad_function_call
    }

    return 0;
}
```

##  `std::function`与多态

由于`std::function`可以存储任意可调用对象，因此它可以用来实现多态行为。

这意味着可以将不同的函数对象绑定到一个`std::function`上，然后通过调用`std::function`来实现不同的行为。

```cpp
#include <functional>
#include <iostream>

class Animal 
{
public:
    virtual void makeSound() const = 0;
};

class Dog : public Animal
{
public:
    void makeSound() const override 
    {
        std::cout << "Woof!" << std::endl;
    }
};

class Cat : public Animal
{
public:
    void makeSound() const override 
    {
        std::cout << "Meow!" << std::endl;
    }
};

int main() 
{
    std::function<void(const Animal&)> makeSoundFunc;

    Dog dog;
    Cat cat;

    makeSoundFunc = [](const Animal& animal) { animal.makeSound(); };

    makeSoundFunc(dog); // Output: Woof!
    makeSoundFunc(cat); // Output: Meow!

    return 0;
}
```

在上述例子中，我们使用`std::function`将不同的动物对象（`Dog`和`Cat`）的`makeSound()`方法封装起来，然后通过`makeSoundFunc()`调用不同的动物的声音输出。

`std::function`是C++中一个非常有用的工具，特别是在需要实现多态行为或在接口设计中解耦函数的返回类型和参数类型时。

它使得处理函数对象变得更加灵活和通用。



## `std::function`与非静态成员函数

类的非静态成员函数是依赖于实例化对象的，需要先创建并实例化出对象，使用`std::function`封装类的非静态成员函数有三种方法：使用lambda表达式、使用`std::bind`、直接封装。

下面将给出使用lambda表达式和直接封装的代码示例。

lambda表达式：

```c++
#include <iostream>
#include <functional>

class MyClass
{
public:
    void nonStaticFunction(int value)
    {
        std::cout << "Non-static function called with value: " << value << std::endl;
    }
};

int main() 
{
    MyClass obj;

    // 使用lambda表达式也可以将类的实例和成员函数捕获，创建一个可调用的对象
    std::function<void(int)> func = [&obj](int value){obj.nonStaticFunction(value);};

    // 现在可以像调用普通函数一样调用封装的成员函数
    func(100);

    return 0;
}
```

直接封装：

```c++
#include <iostream>
#include <functional>

class MyClass
{
public:
    int add(int a, int b)
    {
        return a + b;
    }
};

int main()
{
    MyClass obj;

    std::function<int(MyClass&, int, int)> func = &MyClass::add;
	//调用
    func();
    
    return 0;
}
```

使用`std::bind`将在后续讲解。

## `std::function`的成员函数

`std::function`是一个通用的函数封装器，它提供了一系列成员函数来管理和操作封装的可调用对象。

下面是`std::function`的一些重要成员函数及其作用：

-  构造函数：
   - `function::function()`：默认构造函数，创建一个空的`std::function`对象。
   - `function::function(nullptr_t)`：构造一个空的`std::function`对象。
   - `function::function(const function&)`：复制构造函数，用于创建一个`std::function`对象，复制另一个`std::function`对象的内容。

-  赋值和重置：
   - `function::operator=`：赋值运算符，用于将一个`std::function`对象赋值给另一个。
   - `function::operator=(nullptr_t)`：将`std::function`对象重置为空。

-  调用和运行时类型判断：
   - `function::operator()`：函数调用运算符，用于调用封装的可调用对象。
   - `function::target()`：返回指向封装的可调用对象的指针，可以用于判断其运行时类型。
   - `function::target_type()`：返回封装的可调用对象的类型。

-  检查是否为空：
   - `function::operator bool()`：将`std::function`对象转换为`bool`值，判断是否为空。

- 交换两个对象的内容：

  - `function::swap()`：用于交换两个`std::function`对象的内容。

    `swap()`函数允许在不复制或移动可调用对象的情况下，高效地交换两个`std::function`对象的内容。这对于需要在运行时更改`std::function`对象的封装内容非常有用。

    `swap()`函数是无异常的 (`noexcept`)，因此它不会引发异常。这使得在涉及异常安全性的代码中使用`swap()`函数非常安全。



请注意，`std::function`的成员函数和操作符的行为会根据封装的可调用对象的类型而有所不同。

例如：

- 如果封装的是一个函数指针，那么调用运算符的行为就类似于直接调用该函数。

- 如果封装的是一个函数对象，那么调用运算符将调用函数对象的`operator()`成员函数。

这些成员函数使得`std::function`能够灵活地处理不同类型的可调用对象，并提供了一致的接口来管理和使用这些对象。

# `std::bind`

## 概述

在C++中，`std::bind`是一个非常有用的函数模板，用于创建一个函数对象，可以将参数绑定到该对象，并延迟调用相应的函数。它的主要作用是部分应用函数参数或重新排序函数参数。`std::bind`位于`<functional>`头文件中，并在C++11及以上版本的标准中提供支持。

`std::bind`的语法如下：

```cpp
template< class F, class... Args >
std::function<F(Args...)> bind( F&& f, Args&&... args );
```

`std::bind`接受一个可调用对象 `f` 和若干个参数 `args`（这些参数可以是常量、变量或者其他函数对象），返回一个新的函数对象，该函数对象可以在稍后调用，实际执行时，将会使用绑定的参数和`f`原来的参数一起传递。

## 绑定自由函数

```cpp
#include <functional>
#include <iostream>

int add(int a, int b) 
{
    return a + b;
}

int main() 
{
    auto func = std::bind(add, 10, 20);
    std::cout << func() << std::endl; // 输出 30
    return 0;
}
```

在这个例子中，我们通过`std::bind`将`add`函数的前两个参数绑定为`10`和`20`。

生成的`func`函数对象可以直接调用，而无需再传递`add`函数的前两个参数。

## 绑定成员函数

```cpp
#include <functional>
#include <iostream>

class Calculator 
{
public:
    int add(int a, int b) 
    {
        return a + b;
    }
};

int main() {
    Calculator calc;
    auto func = std::bind(&Calculator::add, &calc, 10, 20);
    std::cout << func() << std::endl; // 输出 30
    return 0;
}
```

在这个例子中，我们使用`std::bind`将`Calculator`类的成员函数`add`绑定到对象`calc`上，并绑定前两个参数为`10`和`20`。

注意：非静态成员函数是依赖于实例化对象的。

生成的`func`函数对象可以直接调用，并在调用时使用绑定的对象和参数。

## 占位符

`std::bind`的占位符是一个特殊的标记，用于表示在调用绑定后的函数对象时，哪些参数需要从调用时的实际参数中获取，而哪些参数是已经绑定好的。

占位符以`std::placeholders::_N`的形式表示，其中`N`是一个非负整数，表示参数的位置索引。

`std::placeholders::_1`表示第一个参数，`std::placeholders::_2`表示第二个参数，以此类推。

在使用`std::bind`时，可以在绑定的函数对象中使用占位符，然后在调用函数对象时，传递实际的参数来替换这些占位符，以完成参数的绑定。

```cpp
#include <functional>
#include <iostream>

int add(int a, int b, int c) 
{
    return a + b + c;
}

int main() 
{
    auto func = std::bind(add, std::placeholders::_2, std::placeholders::_1, std::placeholders::_3);
    std::cout << func(10, 20, 30) << std::endl; // 输出 60  (20 + 10 + 30)
    return 0;
}

```

在这个例子中，我们使用`std::bind`将函数`add`的参数重新排列，通过占位符的位置调整了参数的顺序。

`std::placeholders::_2`表示实际调用时的第二个参数，`std::placeholders::_1`表示实际调用时的第一个参数，`std::placeholders::_3`表示实际调用时的第三个参数。

==注意：参数顺序与`std::placeholders::_N`中N的顺序是一一对应的。假如只有`std::placeholders::_2`而没有`std::placeholders::_1`，那么只传入一个参数时将会报错，传入两个参数时第一个参数将会被忽略，以此类推。==

## 绑定到lambda函数

```cpp
#include <functional>
#include <iostream>

int main() 
{
    int base = 10;
    auto func = std::bind([](int x, int y) { return x + y + base; }, 20, std::placeholders::_1);
    std::cout << func(30) << std::endl; // 输出 60 (20 + 30 + 10)
    return 0;
}
```

在这个例子中，我们使用`std::bind`将一个Lambda函数绑定，并在绑定时指定了其中的一个参数为`20`，另一个参数使用`std::placeholders::_1`占位符，表示稍后调用`func`时传递的参数。同时，Lambda函数内部使用了外部的变量`base`，这个变量在绑定时被捕获了。

## `std::bind`和`std::function`结合使用

可以使用`std::function`来封装类中的非静态成员函数。

要封装类中的非静态成员函数，需要使用`std::bind`或lambda表达式，将类的实例（对象）绑定到成员函数上。

这样，就可以将成员函数封装成一个可调用的对象，然后再将其传递给`std::function`。

下面是一个示例代码，演示了如何使用`std::function`配合`std::bind`封装类中的非静态成员函数：

```cpp
#include <iostream>
#include <functional>

class MyClass
{
public:
    void nonStaticFunction(int value)
    {
        std::cout << "Non-static function called with value: " << value << std::endl;
    }
};

int main() 
{
    MyClass obj;

    // 使用std::bind将类的实例和成员函数绑定，创建一个可调用的对象
    std::function<void(int)> func1 = std::bind(&MyClass::nonStaticFunction, &obj, std::placeholders::_1);

    // 现在可以像调用普通函数一样调用封装的成员函数
    func1(42);

    return 0;
}
```

在上面的示例中，`func1`是`std::function`类型的对象，封装了`MyClass`类的`nonStaticFunction`成员函数。

`func1`使用`std::bind`将`obj`对象和成员函数绑定在一起。

请注意，在使用`std::bind`时，需要传递类实例的指针作为第一个参数，以确保成员函数能够正确访问类的实例。

而在使用lambda表达式时，可以通过捕获列表来捕获类实例，以便在lambda函数体内使用。

# 继承构造

在C++11中引入了继承构造特性（Inheriting Constructors），允许派生类继承基类的构造函数（默认构造函数、拷贝构造函数、移动构造函数除外）。

这种特性简化了代码，避免了在派生类中重新实现相同的构造函数。

继承构造特性通过在派生类中使用`using`声明语句来实现。

通过`using`声明，派生类可以直接使用基类的构造函数，而不需要重新定义或调用它们。

示例：

```cpp
#include <iostream>

class Base
{
public:
    Base(int x) 
    {
        std::cout << "Base constructor called with x = " << x << std::endl;
    }
};

class Derived : public Base 
{
public:
    using Base::Base;  // 继承基类的构造函数

    void DoSomething() 
    {
        std::cout << "Doing something in the derived class." << std::endl;
    }
};

int main() 
{
    Derived derived(42);
    derived.DoSomething();

    return 0;
}
```

在上面的代码中，`Base`类有一个接受一个整数参数的构造函数。

`Derived`类通过使用`using Base::Base;`语句继承了`Base`的构造函数。

这意味着在创建`Derived`对象时，可以直接使用`Base`类的构造函数，并且传递相同的参数。

输出：

```
Base constructor called with x = 42
Doing something in the derived class.
```

可以看到，通过继承构造特性，`Derived`类实例化时会自动调用`Base`类的构造函数，并传递相应的参数。

继承构造特性还可以用于多重继承的情况，允许派生类继承多个基类的构造函数。

如果基类构造函数有默认参数，派生类也会继承这些默认参数。

继承构造特性简化了代码编写，并提高了代码的可读性和维护性。

注意事项：

- 继承构造一般只适用于派生类中没有新增成员变量的情况下，继承构造只能初始化基类中的成员变量，不能初始化派生类中的成员变量，如果派生类新增了成员变量，那么继承构造的意义不大。

- 使用继承构造时，派生类不能是虚继承基类，否则编译报错。
- 派生类一旦使用继承构造，那么编译器不会再提供默认构造函数。
- 派生类只能继承可见的基类构造函数。如果基类的构造函数是私有的或受保护的，派生类无法使用继承构造特性。只有公有的基类构造函数才能被继承。
- 如果派生类自己定义了与基类构造函数相同的构造函数（包括参数类型和个数），那么继承构造特性将失效。派生类不会继承基类的构造函数，而是使用自己定义的构造函数。
- 继承构造特性会继承基类构造函数的默认参数。这意味着在派生类中，可以选择省略这些默认参数或者提供新的默认参数值。
- 如果派生类从多个基类继承构造函数，并且这些构造函数具有相同的签名，那么在派生类中使用继承构造特性时会引发重载解析问题。这时需要使用限定符或显式地指定所需的构造函数。
- 如果基类使用虚拟继承（virtual inheritance），派生类无法继承其构造函数。在这种情况下，需要在派生类中手动定义构造函数，并在初始化列表中调用基类的构造函数。

# 委托构造

C++11引入了委托构造（Delegating Constructors）的特性，它允许一个构造函数在同一个类中调用另一个构造函数来完成对象的初始化。

这样可以避免在类中重复编写相似的初始化代码，提高代码的可读性和维护性。

在使用委托构造时，可以通过在构造函数的初始化列表中使用类似于函数调用的语法来调用其他构造函数。

下面是一个简单的示例代码，演示了如何使用委托构造：

```cpp
#include <iostream>

class MyClass
{
public:
    MyClass() : MyClass(0) 
    {
        std::cout << "Default constructor" << std::endl;
    }

    MyClass(int x) : MyClass(x, 0) 
    {
        std::cout << "Constructor with one parameter: " << x << std::endl;
    }

    MyClass(int x, int y) : x_(x), y_(y) 
    {
        std::cout << "Constructor with two parameters: " << x << ", " << y << std::endl;
    }

private:
    int x_;
    int y_;
};

int main() 
{
    MyClass obj1;               // 调用默认构造函数
    MyClass obj2(42);           // 调用带一个参数的构造函数
    MyClass obj3(10, 20);       // 调用带两个参数的构造函数

    return 0;
}
```

在上面的代码中，`MyClass`类中定义了三个构造函数。

默认构造函数调用了带一个参数的构造函数，带一个参数的构造函数又调用了带两个参数的构造函数。

这种构造函数之间的相互调用就是委托构造。

输出：

```
Constructor with two parameters: 0, 0
Default constructor
Constructor with one parameter: 42
Constructor with two parameters: 10, 20
```

可以看到，通过使用委托构造，不需要在每个构造函数中重复编写相同的初始化代码。

相反，每个构造函数只需要关注它自己特定的初始化逻辑，并将共享的初始化工作委托给其他构造函数。

需要注意的是，委托构造函数的调用发生在当前构造函数的初始化列表中。

委托构造函数必须位于当前构造函数初始化列表的最开始位置。

这是因为在初始化列表中的其他成员初始化之前，必须先选择正确的构造函数进行委托。

委托构造使得构造函数的代码更加简洁和易于维护。它是提高代码可读性和减少重复代码的有用工具。























# 智能指针

## 智能指针的概述

---

C++的指针包括两种：

- 原始指针（raw pointer)
- 智能指针

智能指针是原始指针的封装，其优点是会自动分配内存，不用担心潜在的内存泄露。

并不是所有的指针都可以封装成智能指针，很多时候原始指针要更方便。

C++11中通过引入智能指针的概念，使得C++程序员不需要手动释放内存。

智能指针的种类：

- `std:unique_ptr`
- `std::shared_ptr`
- `std::weak_ptr`

- `std::auto ptr`（已被废弃）



各种指针中，最常用的是裸指针，其次是`unique _ptr`和`shared ptr`

`weak_ptr`是`shared _ptr`的一个补充，应用场景较少。



智能指针只解决一部分问题，即独占、共享、所有权、指针的释放、传输

智能指针没有从根本上解决C++内存安全问题，不加以注意依然会造成内存安全问题

## `unique_ptr`（独占指针）

---

### 概念和用法

---

`unique_ptr`是一种智能指针，用于管理动态分配的对象。

它提供了一种独占式所有权模式，即==一个对象只能由一个`unique_ptr`拥有==。

当`unique_ptr`被销毁或重置时，它所拥有的对象也会被销毁。

以下是`unique_ptr`的主要特点和用法：

- **头文件引入**：

  `unique_ptr`位于 `<memory>` 头文件中，要使用它，需要包含该头文件。

- **对象的所有权**：

  `unique_ptr`通过将对象包装在一个指针内部，拥有对该对象的独占所有权。这意味着没有其他指针可以同时指向该对象。

- **动态内存分配**：

  通常，`unique_ptr`用于管理动态分配的对象。可以使用`new`关键字来创建一个对象，并将其传递给`unique_ptr`的构造函数。

  ```c++
  std::unique_ptr<int> ptr(new int); // 创建一个动态分配的int对象
  ```

- **指针语义**：

  `unique_ptr`具有与原始指针类似的语义，可以像使用原始指针一样对待它。

  ```c++
  std::unique_ptr<int> ptr(new int); // 创建一个动态分配的int对象
  *ptr = 10;      // 对动态分配的对象进行赋值
  int value = *ptr; // 从指针获取对象的值

- **移动语义**：

  由于`unique_ptr`拥有对象的独占所有权，因此它可以被移动，但不能被复制。

  这意味着可以将`unique_ptr`转移到另一个`unique_ptr`，而原始的`unique_ptr`将失去对对象的所有权。

  ```c++
  std::unique_ptr<int> ptr1(new int);
  std::unique_ptr<int> ptr2 = std::move(ptr1); // 转移ptr1的所有权给ptr2

- **释放内存**：

  当`unique_ptr`超出范围、被重置或被销毁时，它所拥有的对象会自动被销毁。

  这意味着不需要手动调用`delete`来释放内存，从而避免了内存泄漏。

  ```c++
  std::unique_ptr<int> ptr(new int);
  // ...
  ptr.reset(); // 重置unique_ptr，对象会被销毁
  // unique_ptr生命周期结束对象也会被自动销毁
  ```

- **空指针检查**：

  可以使用`unique_ptr`的`get`函数来检查它是否指向一个有效的对象。

  ```c++
  std::unique_ptr<int> ptr;
  if (ptr.get() != nullptr) 
  {
      // ptr指向一个有效的对象
  }

- **自定义删除器**：

   `unique_ptr`还可以使用自定义的删除器函数或函数对象来管理对象的销毁。
   
   ```cpp
   struct CustomDeleter 
   {
       void operator()(int* ptr) const 
       {
           // 自定义的对象销毁操作
           delete ptr;
       }
   };
   
   std::unique_ptr<int, CustomDeleter> ptr(new int, CustomDeleter());
   //第二个参数即重载()的仿函数，模板参数中删除器类型必须指定，函数参数可以不指定
   //std::unique_ptr<int, CustomDeleter> ptr(new int);//这样也行，效果一样
   ```

`unique_ptr`提供了一种安全且方便的方式来管理动态分配的对象，可以避免内存泄漏和手动内存管理的麻烦。

但需要注意的是，由于其独占性质，`unique_ptr`不适用于需要多个指针共享所有权的情况。在这种情况下，应该考虑使用`shared_ptr`智能指针。

### 错误使用示例

---

关于`unique_ptr`的独占性，以下是一些可能导致错误的示例：

**错误示例 1：复制`unique_ptr`**

```cpp
std::unique_ptr<int> ptr1(new int);
std::unique_ptr<int> ptr2 = ptr1; // 错误！不能复制unique_ptr
```

由于`unique_ptr`的独占性，它不能被复制。在上面的示例中，试图将`ptr1`复制给`ptr2`将导致编译错误。

**错误示例 2：使用原始指针共享所有权**

```cpp
std::unique_ptr<int> ptr(new int);
int* rawPtr = ptr.get(); // 获取原始指针
std::shared_ptr<int> sharedPtr(rawPtr); // 错误！不能与shared_ptr共享所有权
```

由于`unique_ptr`的独占性，它不能与`shared_ptr`共享所有权。

在上面的示例中，将`unique_ptr`的原始指针传递给`shared_ptr`的构造函数是错误的，会导致多个智能指针同时管理同一个对象，可能引发内存释放问题。

**错误示例 3：返回局部的`unique_ptr`**

```cpp
std::unique_ptr<int> createPtr()
{
    std::unique_ptr<int> ptr(new int);
    return ptr; // 错误！返回局部unique_ptr的所有权
}

std::unique_ptr<int> ptr = createPtr(); // 错误！悬空指针
```

在上面的示例中，`createPtr`函数试图返回一个局部创建的`unique_ptr`，这是错误的。当函数返回时，局部对象将被销毁，导致指向无效内存的悬空指针。

**错误示例 4：将相同的原始指针传递给多个`unique_ptr`**

```cpp
int* rawPtr = new int;
std::unique_ptr<int> ptr1(rawPtr);
std::unique_ptr<int> ptr2(rawPtr); // 错误！多个unique_ptr管理同一个原始指针
```

在上面的示例中，试图将相同的原始指针传递给多个`unique_ptr`是错误的。这将导致多个智能指针同时尝试删除同一个内存块，可能导致重复释放或悬空指针。

需要特别注意`unique_ptr`的独占性质，并避免以上错误，以确保正确使用和管理动态分配的对象。

### 成员函数详解

---

`unique_ptr`类提供了一系列成员函数来管理和操作智能指针，以下是其中一些常用的成员函数及其作用：

- **`reset()`**：重置`unique_ptr`，释放当前拥有的对象，并接管新的对象。如果没有参数，则释放当前调用对象拥有的对象，`uinque_ptr`变为悬空指针。

   ```cpp
   std::unique_ptr<int> ptr(new int);
   // ...
   ptr.reset(new int); // 重置unique_ptr，释放旧对象并接管新对象
   //ptr.reset()// 释放拥有的对象，变为悬空指针
   ```

- **`release()`**：释放`unique_ptr`对对象的所有权，并返回指向该对象的原始指针，`unique_ptr`变为悬空指针。

   ```cpp
   std::unique_ptr<int> ptr(new int);
   int* rawPtr = ptr.release(); // 释放unique_ptr对对象的所有权，返回原始指针
   // ...
   //需要手动释放rawPtr
   delete rawPtr;
   ```

- **`get()`**：返回指向`unique_ptr`管理的对象的原始指针。

   ```cpp
   std::unique_ptr<int> ptr(new int);
   int* rawPtr = ptr.get(); // 获取指向对象的原始指针
   ```

- **`operator*()`**：重载解引用操作符，返回`unique_ptr`管理对象的引用。

   ```cpp
   std::unique_ptr<int> ptr(new int);
   *ptr = 42; // 解引用unique_ptr并赋值
   ```

- **`operator->()`**：重载箭头操作符，返回指向`unique_ptr`管理对象的指针。

   ```cpp
   std::unique_ptr<std::string> ptr(new std::string("Hello"));
   std::cout << ptr->size() << std::endl; // 使用箭头操作符访问对象的成员函数
   ```

- **`operator bool()`**：将`unique_ptr`转换为布尔值，判断指针是否为空（是否指向对象）。

   ```cpp
   std::unique_ptr<int> ptr;
   if (ptr) 
   {
       // 指针不为空
   }
   ```

- **`operator=`**：重载赋值操作符，用于将一个`unique_ptr`赋值给另一个。赋值后，左侧的`unique_ptr`接管右侧的对象，并且右侧的`unique_ptr`变为悬空指针。

   ```cpp
   std::unique_ptr<int> ptr1(new int);
   std::unique_ptr<int> ptr2;
   ptr2 = std::move(ptr1); // 将ptr1的所有权转移给ptr2，ptr1变为悬空指针
   ```
   
- **`operator[]`**：允许使用下标操作符访问`unique_ptr`管理的数组对象。

    ```cpp
    std::unique_ptr<int[]> arr(new int[5]);
    arr[0] = 1; // 访问数组元素
    ```

- **`swap()`**：交换两个`unique_ptr`对象所管理的对象。

   ```cpp
   std::unique_ptr<int> ptr1(new int(1));
   std::unique_ptr<int> ptr2(new int(2));
   ptr1.swap(ptr2); // 交换ptr1和ptr2的对象
   ```
   
- **`get_deleter()`**：获取`unique_ptr`中自定义的删除器函数或函数对象。

   ```c++
   #include <memory>
   #include <iostream>
   using namespace std;
   
   struct Deleter 
   {
       void operator()(int* ptr) 
       {
           std::cout << "自定义删除器 "<< std::endl;
           delete ptr;
       }
   };
   
   int main() 
   {
       {
           int* rawPtr = new int(99);
           std::unique_ptr<int, Deleter> uniquePtr(rawPtr, Deleter());
           //std::unique_ptr<int, Deleter> uniquePtr(rawPtr);//第二个函数参数可以省略
           uniquePtr.get_deleter()(new int(0));
       }
   //输出：
       //自定义删除器
       //自定义删除器
       return 0;
   }
   ```

   

### 使用`make_unique`创建和初始化

---

`std::make_unique`是C++14中引入的一个辅助函数模板，用于创建和初始化`std::unique_ptr`对象，以更方便地进行动态内存分配和对象构造。

它接受类型`T`和可变数量的参数`Args`，并返回一个`std::unique_ptr<T>`对象。

使用`std::make_unique`的主要优势是它将动态内存分配和对象构造组合在一起，使代码更简洁、更安全。

==它避免了直接使用`new`运算符来手动创建`unique_ptr`对象==，并确保在发生异常时能够正确地销毁已分配的内存。

以下是使用`std::make_unique`的示例：

```cpp
#include <memory>

struct MyClass 
{
    MyClass(int a, double b) 
    {
        // 对象的构造逻辑
    }
};

int main() 
{
    std::unique_ptr<MyClass> ptr = std::make_unique<MyClass>(42, 3.14);
    // 使用make_unique创建unique_ptr，并传递构造参数
    // 在此示例中，将调用MyClass的构造函数
    return 0;
}
```

在上面的示例中，`std::make_unique`用于创建一个`std::unique_ptr<MyClass>`对象，并传递构造参数`42`和`3.14`给`MyClass`的构造函数。

这样，通过`make_unique`可以在一行代码中完成对象的动态分配和构造。

需要注意的是，`std::make_unique`在C++14中引入，因此如果使用较旧的C++标准（如C++11或更早），则无法直接使用该函数模板。

在这种情况下，可以通过编写自定义的辅助函数来模拟`std::make_unique`的行为。

## `shared_ptr`（共享指针）

---

### 概念和用法

---

`shared_ptr`是一种智能指针，用于管理动态分配的对象。

与`unique_ptr`不同，`shared_ptr`实现了共享所有权的语义，允许多个智能指针共同管理同一个对象。

它通过使用引用计数来跟踪对象的所有权，确保对象在没有引用时被正确释放。

以下是`shared_ptr`的主要特点和用法：

- **头文件引入**：

   `shared_ptr`位于 `<memory>` 头文件中，因此要使用它，需要包含该头文件。

- **对象的共享所有权**：

   `shared_ptr`通过在内部维护一个引用计数，允许多个智能指针共享对同一对象的所有权。

   ```cpp
   std::shared_ptr<int> ptr1(new int);
   std::shared_ptr<int> ptr2 = ptr1; // 共享ptr1对对象的所有权
   ```

- **动态内存分配**：

   通常，`shared_ptr`用于管理动态分配的对象。可以使用`new`关键字来创建一个对象，并将其传递给`shared_ptr`的构造函数。

   ```cpp
   std::shared_ptr<int> ptr(new int); // 创建一个动态分配的int对象
   ```

- **引用计数**：

   `shared_ptr`内部维护了一个引用计数，跟踪有多少个`shared_ptr`实例共享同一个对象。

   每当创建或复制一个`shared_ptr`时，引用计数会增加。当`shared_ptr`被销毁或重置时，引用计数会减少。

   如果有多个`shard_ptr`共享同一个对象，当销毁或释放其中一个`shard_ptr`时，只是将这个`shard_ptr`和其所管理的内存空间解除绑定，使这个被销毁的`shard_ptr`无法再操纵原先的堆区空间（`shard_ptr`置空），并且将计数器减一，但是其他未被销毁的`shard_ptr`仍然可以操纵堆区内存。

   当引用计数为零时，对象会被自动销毁。

- **拷贝和移动语义**：

   `shared_ptr`可以通过拷贝构造函数和拷贝赋值运算符进行复制。

   每个`shared_ptr`实例都会增加引用计数。同时，它也支持移动语义，允许通过移动构造函数和移动赋值运算符将对象的所有权转移到另一个`shared_ptr`。

   ```cpp
   std::shared_ptr<int> ptr1(new int);
   std::shared_ptr<int> ptr2 = ptr1;   // 拷贝，引用计数增加
   std::shared_ptr<int> ptr3 = std::move(ptr1); // 移动，ptr1的所有权转移到ptr3，ptr1变为空指针
   ```

- **循环引用问题**：

   由于`shared_ptr`的引用计数机制，当存在循环引用时，对象可能不会被正确释放，导致内存泄漏。

   为了解决这个问题，C++11引入了`weak_ptr`作为`shared_ptr`的补充，用于解决循环引用的管理问题。

   关于循环引用将在下一节讲解。这里可以只做了解。

   ```cpp
   std::shared_ptr<A> ptrA(new A);
   std::shared_ptr<B> ptrB(new B);
   ptrA->b = ptrB; // 假设A中有一个成员指向B
   ptrB->a = ptrA; // 假设B中有一个成员指向A
   				// 循环引用，可能导致对象无法正确释放
   
   // 使用weak_ptr解决循环引用
   std::shared_ptr<A> ptrA(new A);
   std::shared_ptr<B> ptrB(new B);
   ptrA->b = std::weak_ptr<B>(ptrB);
   ptrB->a = std::weak_ptr<A>(ptrA);
   ```

- **自定义删除器**：

   `shared_ptr`也可以使用自定义的删除器函数或函数对象来管理对象的销毁，类似于`unique_ptr`。
   
   ```cpp
   struct CustomDeleter 
   {
       void operator()(int* ptr) const 
       {
           // 自定义的对象销毁操作
           delete ptr;
       }
   };
   
   std::shared_ptr<int> ptr(new int, CustomDeleter());
   ```

`shared_ptr`提供了一种灵活的方式来管理动态分配的对象，允许多个指针共享对同一对象的所有权。

需要注意循环引用问题，并根据具体的使用场景选择合适的智能指针类型。

### 错误使用示例

---

当涉及到`shared_ptr`的使用时，以下是一些可能导致错误的示例：

**错误示例 1：使用原始指针删除对象**

```cpp
int* rawPtr = new int;
std::shared_ptr<int> ptr(rawPtr);
delete rawPtr; // 错误！不应该直接删除由shared_ptr管理的对象
```

由于`shared_ptr`负责管理对象的内存，因此不应该直接使用`delete`来删除由`shared_ptr`管理的对象。在上面的示例中，试图通过`delete`关键字删除原始指针，这将导致`shared_ptr`尝试删除一个无效的指针，可能引发未定义行为。

**错误示例 2：使用`shared_ptr`管理静态对象或栈上对象**

```cpp
int value = 42;
std::shared_ptr<int> ptr(&value); // 错误！不应该使用shared_ptr管理静态或栈上对象
```

`shared_ptr`应该用于管理动态分配的对象，而不是静态对象或栈上对象。

在上面的示例中，试图将一个指向静态对象的指针传递给`shared_ptr`的构造函数是错误的。

**错误示例 3：使用裸指针与`shared_ptr`共享所有权**

```cpp
int* rawPtr = new int;
std::shared_ptr<int> ptr1(rawPtr);
std::shared_ptr<int> ptr2(rawPtr); // 错误！不能与shared_ptr共享同一个原始指针
```

由于`shared_ptr`采用共享所有权的模式，它不适用于与其他`shared_ptr`或`weak_ptr`共享同一个原始指针。

这段代码是错误的，因为它试图将同一个原始指针 `rawPtr` 传递给两个独立的 `shared_ptr` 对象 `ptr1` 和 `ptr2`。这会导致引用计数错误，可能导致多次释放同一内存块，从而引发未定义行为。

将同一个原始指针直接传递给多个 `shared_ptr` 对象是错误的，会导致引用计数错误。

正确的方式是通过拷贝构造函数或拷贝赋值运算符从一个 `shared_ptr` 获得原始指针的所有权，并确保它们共享同一个对象的引用计数。

**错误示例 4：循环引用导致内存泄漏**

```cpp
class Node 
{
public:
    std::shared_ptr<Node> next;
};

std::shared_ptr<Node> node1(new Node);
std::shared_ptr<Node> node2(new Node);
node1->next = node2;
node2->next = node1; // 错误！循环引用导致对象无法正确释放
```

当存在循环引用时，对象无法被正确释放，导致内存泄漏。

在上面的示例中，`node1`和`node2`之间形成了循环引用，它们相互持有对方的`shared_ptr`，当`node1`生命周期结束时会进行释放，但是内部有一个`shared_ptr`的智能指针于是就要释放这个智能指针，这个智能指针指向是`node2`，于是就要释放`node2`，但是`node2`内部的`shared_ptr`的智能指针又指向`node1`，于是又要释放`node1`，如此形成闭环，导致对象无法正确释放。

### 成员函数详解

---

`shared_ptr`类提供了一系列成员函数来管理和操作智能指针，以下是它的常用成员函数及其作用：

- **`reset()`**：重置`shared_ptr`，释放当前拥有的对象，并接管新的对象。

   ```cpp
   std::shared_ptr<int> ptr(new int);
   // ...
   ptr.reset(new int); // 重置shared_ptr，释放旧对象并接管新对象
   ```

- **`get()`**：返回指向`shared_ptr`管理的对象的原始指针。

   ```cpp
   std::shared_ptr<int> ptr(new int);
   int* rawPtr = ptr.get(); // 获取指向对象的原始指针
   ```

- **`use_count()`**：返回当前`shared_ptr`对象所管理对象的引用计数，即共享该对象的智能指针的数量。

   ```cpp
   std::shared_ptr<int> ptr1(new int);
   std::shared_ptr<int> ptr2 = ptr1;
   int count = ptr1.use_count(); // 获取引用计数，值为2
   ```

- **`unique()`**：检查当前`shared_ptr`是否是唯一的（引用计数为1），即没有其他智能指针与之共享对象。

   ```cpp
   std::shared_ptr<int> ptr1(new int);
   std::shared_ptr<int> ptr2 = ptr1;
   if (ptr1.unique()) 
   {
       // ptr1是唯一的智能指针
   }
   ```

- **`operator*()`**：重载解引用操作符，返回`shared_ptr`管理对象的引用。

   ```cpp
   std::shared_ptr<int> ptr(new int);
   *ptr = 42; // 解引用shared_ptr并赋值
   ```

- **`operator->()`**：重载箭头操作符，返回指向`shared_ptr`管理对象的指针。

   ```cpp
   std::shared_ptr<std::string> ptr(new std::string("Hello"));
   std::cout << ptr->size() << std::endl; // 使用箭头操作符访问对象的成员函数
   ```

- **`operator bool()`**：将`shared_ptr`转换为布尔值，判断指针是否为空（是否指向对象）。

   ```cpp
   std::shared_ptr<int> ptr;
   if (ptr) 
   {
       // 指针不为空
   }
   ```

- **`swap()`**：交换两个`shared_ptr`对象所管理的对象。

   ```cpp
   std::shared_ptr<int> ptr1(new int(1));
   std::shared_ptr<int> ptr2(new int(2));
   ptr1.swap(ptr2); // 交换ptr1和ptr2的对象
   ```

- **`operator=`**：重载赋值操作符，用于将一个`shared_ptr`赋值给另一个。赋值后，左侧的`shared_ptr`接管右侧的对象，并且引用计数增加。

   ```cpp
   std::shared_ptr<int> ptr1(new int);
   std::shared_ptr<int> ptr2;
   ptr2 = ptr1; // 将ptr1的对象所有权转移给ptr2，并增加引用计数
   ```

- **`owner_before()`**：比较两个`shared_ptr`对象的所有权关系，用于确定它们在所有权层级中的位置。

    ```cpp
    std::shared_ptr<int> ptr1(new int);
    std::shared_ptr<int> ptr2(new int);
    if (ptr1.owner_before(ptr2)) 
    {
        // ptr1在ptr2之前（所有权层级中）
    }
    ```

- **`reset()`（重载版本）**：重置`shared_ptr`，释放当前拥有的对象，并接管新的对象，并使用自定义删除器。

    ```cpp
    struct CustomDeleter 
    {
        void operator()(int* ptr) const 
        {
            // 自定义的对象销毁操作
            delete ptr;
        }
    };
    
    std::shared_ptr<int> ptr(new int, CustomDeleter());
    // ...
    ptr.reset(new int, CustomDeleter()); // 重置shared_ptr，释放旧对象并接管新对象
    ```

### 使用`make_shared`创建和初始化

**`make_shared()`**：创建一个包含动态分配对象的`shared_ptr`，并在分配期间同时构造对象。

使用方式与`make_unique`几乎一样详细参考上节使用《`make_unique`创建和初始化》的详解。

```cpp
std::shared_ptr<int> ptr = std::make_shared<int>(42);
// 使用make_shared创建shared_ptr，并传递构造参数
```

### `enable_shared_from_this`

`std::enable_shared_from_this`是一个模板类，定义在`<memory>`头文件中，它是为了支持在已由`std::shared_ptr`管理的对象内部安全地获取指向自身的`std::shared_ptr`而设计的。

为什么要使用`enable_shared_from_this`:

- 在已由`std::shared_ptr`管理的对象内部安全地获取指向自身的`std::shared_ptr`，它允许对象自己管理其共享所有权。

- 共享所有权：当一个对象需要与其他对象共享所有权时，可以使用`std::shared_ptr`来管理它们之间的关系。通过使用`std::enable_shared_from_this`，对象可以方便地获取指向自身的共享指针，并与其他对象共享所有权，从而确保对象在使用期间保持有效，直到没有任何共享指针引用它时才会被销毁。

- 回调函数：在某些情况下，对象可能需要注册回调函数，并在特定事件发生时调用这些回调函数。

  使用`std::enable_shared_from_this`可以安全地将对象自身作为回调函数的参数传递，以避免对象在回调函数执行期间被意外销毁。

- 继承关系：当存在基类和派生类的继承关系时，派生类可以继承`std::enable_shared_from_this`，以便获取指向自身的共享指针。

  这对于在派生类中访问基类成员或在派生类之间建立共享关系非常有用。

使用`std::enable_shared_from_this`需要遵循以下几个步骤：

- 创建一个类并公开继承自`std::enable_shared_from_this`模板类，将该类作为`std::shared_ptr`所管理的对象。

- 在类中添加需要使用`std::shared_ptr`的成员函数，这些函数将内部调用`shared_from_this()`函数来获取指向自身的`std::shared_ptr`。

示例代码：

```cpp
#include <memory>

class MyClass : public std::enable_shared_from_this<MyClass> 
{
public:
    std::shared_ptr<MyClass> getSharedPointer() 
    {
        return shared_from_this();
    }
};

int main() 
{
    std::shared_ptr<MyClass> ptr1 = std::make_shared<MyClass>();
    std::shared_ptr<MyClass> ptr2 = ptr1->getSharedPointer();
    
    // ptr1和ptr2指向同一个对象
    if (ptr1 == ptr2) 
    {
        std::cout << "ptr1 and ptr2 point to the same object." << std::endl;
    }
    
    return 0;
}
```

在上述示例中，`MyClass`公开继承自`std::enable_shared_from_this<MyClass>`，并定义了`getSharedPointer()`成员函数。

在`getSharedPointer()`函数内部，我们调用了`shared_from_this()`函数，该函数将返回一个指向当前对象的`std::shared_ptr`。

在`main()`函数中，我们首先创建了一个`std::shared_ptr`指向`MyClass`的对象`ptr1`，然后通过调用`ptr1->getSharedPointer()`获取了另一个指向相同对象的`std::shared_ptr`，即`ptr2`。由于使用了`shared_from_this()`，`ptr1`和`ptr2`指向的是同一个对象，它们共享对象的所有权。

需要注意的是，`shared_from_this()`只能在已由`std::shared_ptr`管理的对象内部调用，否则行为是未定义的。

此外，为了安全使用`shared_from_this()`，必须确保在调用该函数之前已经创建了有效的`std::shared_ptr`对象来管理当前对象，否则会导致悬空指针问题。

## `weak_ptr`

### 概念和用法

`weak_ptr`是一种智能指针，用于解决循环引用的问题。（关于循环引用参考上一节的《错误使用示例》中的”错误示例4“）

循环引用是指两个或多个对象彼此保持对方的引用，导致它们无法被正常地销毁。

`weak_ptr`允许创建一个非拥有（non-owning）的指针，它可以观察和访问对象，但不会增加其引用计数。

当被观察的对象被销毁时，`weak_ptr`会自动变为`nullptr`，从而避免悬挂指针（dangling pointer）的问题。

`weak_ptr`通常与`shared_ptr`一起使用。

`weak_ptr`可以从`shared_ptr`创建，但不会增加引用计数。

这样，即使存在循环引用，当所有的`shared_ptr`都释放了对对象的拥有权后，对象也能被正确地销毁。

下面是一个简单的示例代码，演示了如何使用`weak_ptr`：

```cpp
#include <iostream>
#include <memory>

class MyClass 
{
public:
    std::weak_ptr<MyClass> otherPtr;

    ~MyClass() 
    {
        std::cout << "MyClass destroyed" << std::endl;
    }
};

int main() 
{
    std::shared_ptr<MyClass> sharedPtr1 = std::make_shared<MyClass>();
    std::shared_ptr<MyClass> sharedPtr2 = std::make_shared<MyClass>();

    sharedPtr1->otherPtr = sharedPtr2;
    sharedPtr2->otherPtr = sharedPtr1;

    // 释放sharedPtr1和sharedPtr2的拥有权
    sharedPtr1.reset();
    sharedPtr2.reset();

    // 在上面的reset操作后，循环引用被解除，两个MyClass对象都被销毁

    return 0;
}
```

在上面的示例中，我们创建了两个`shared_ptr`对象`sharedPtr1`和`sharedPtr2`，并将它们的`otherPtr`成员变量设置为彼此。这样就形成了一个循环引用。

然后，我们通过调用`reset()`方法释放了`sharedPtr1`和`sharedPtr2`的拥有权。

由于这是最后一次拥有对这两个对象的引用，释放之后的引用计数变为0，`shared_ptr`会自动销毁这两个对象。

使用`weak_ptr`可以避免悬挂指针的问题，因为在对象被销毁后，`weak_ptr`会自动变为`nullptr`。

### 成员函数详解

---

- **`expired()`**：用于检查`weak_ptr`是否失效，即指向的对象是否已经被销毁。如果`weak_ptr`指向的对象已经销毁，则返回`true`；否则返回`false`。

  示例代码：

  ```c++
  std::shared_ptr<int> sharedPtr = std::make_shared<int>(42);
  std::weak_ptr<int> weakPtr = sharedPtr;
  
  sharedPtr.reset(); // 销毁sharedPtr所拥有的对象
  
  if (weakPtr.expired()) 
  {
      std::cout << "weakPtr is expired" << std::endl;
  }
  ```

- **`lock()`**：用于获取一个指向`weak_ptr`所指向对象的`shared_ptr`，如果`weak_ptr`已经失效，则返回一个空的`shared_ptr`（即`nullptr`）。

  示例代码：

  ```c++
  std::shared_ptr<int> sharedPtr = std::make_shared<int>(42);
  std::weak_ptr<int> weakPtr = sharedPtr;
  
  sharedPtr.reset(); // 销毁sharedPtr所拥有的对象
  
  std::shared_ptr<int> lockedPtr = weakPtr.lock();
  if (lockedPtr) 
  {
      std::cout << "Value: " << *lockedPtr << std::endl;
  } 
  else 
  {
      std::cout << "weakPtr is expired" << std::endl;
  }
  ```

- **`use_count()`**：返回与`weak_ptr`共享对象的`shared_ptr`的引用计数。如果`weak_ptr`已经失效，则返回0。

  示例代码：

  ```c++
  std::shared_ptr<int> sharedPtr = std::make_shared<int>(42);
  std::weak_ptr<int> weakPtr = sharedPtr;
  
  std::cout << "sharedPtr use count: " << sharedPtr.use_count() << std::endl;
  std::cout << "weakPtr use count: " << weakPtr.use_count() << std::endl;
  
  std::shared_ptr<int> lockedPtr = weakPtr.lock();
  
  std::cout << "sharedPtr use count: " << sharedPtr.use_count() << std::endl;
  std::cout << "weakPtr use count: " << weakPtr.use_count() << std::endl;
  ```

- **`reset()`**：将`weak_ptr`置为空，不再指向任何对象。

  示例代码：

  ```c++
  std::shared_ptr<int> sharedPtr = std::make_shared<int>(42);
  std::weak_ptr<int> weakPtr = sharedPtr;
  
  std::cout << "weakPtr expired? " << weakPtr.expired() << std::endl;
  
  weakPtr.reset();
  
  std::cout << "weakPtr expired? " << weakPtr.expired() << std::endl;
  ```


- **`owner_before()`**：比较两个`weak_ptr`对象所指向的对象所有权的相对顺序。如果当前`weak_ptr`对象的所指向对象的所有权在另一个`weak_ptr`对象之前，则返回`true`；否则返回`false`。

  该函数用于定义`weak_ptr`对象的排序关系，例如在关联容器（如`std::map`、`std::set`）中使用。

  示例代码：

  ```c++
  std::shared_ptr<int> sharedPtr1 = std::make_shared<int>(42);
  std::shared_ptr<int> sharedPtr2 = std::make_shared<int>(24);
  
  std::weak_ptr<int> weakPtr1 = sharedPtr1;
  std::weak_ptr<int> weakPtr2 = sharedPtr2;
  
  if (weakPtr1.owner_before(weakPtr2))
  {
      std::cout << "weakPtr1's object is owned before weakPtr2's object" << std::endl;
  } 
  else 
  {
      std::cout << "weakPtr2's object is owned before weakPtr1's object" << std::endl;
  }
  ```

- **`swap()`**：交换两个`weak_ptr`对象的内容。

  示例代码：

  ```c++
  std::shared_ptr<int> sharedPtr1 = std::make_shared<int>(42);
  std::shared_ptr<int> sharedPtr2 = std::make_shared<int>(24);
  
  std::weak_ptr<int> weakPtr1 = sharedPtr1;
  std::weak_ptr<int> weakPtr2 = sharedPtr2;
  
  std::cout << "Before swap:" << std::endl;
  std::cout << "weakPtr1 expired? " << weakPtr1.expired() << std::endl;
  std::cout << "weakPtr2 expired? " << weakPtr2.expired() << std::endl;
  
  weakPtr1.swap(weakPtr2);
  
  std::cout << "After swap:" << std::endl;
  std::cout << "weakPtr1 expired? " << weakPtr1.expired() << std::endl;
  std::cout << "weakPtr2 expired? " << weakPtr2.expired() << std::endl;
  ```

- **`operator=`**：允许将一个`std::weak_ptr`对象赋值给另一个`std::weak_ptr`对象。

  赋值操作符执行的是浅拷贝，将右侧的`std::weak_ptr`对象的状态复制到左侧的对象。

  示例代码：

  ```c++
  #include <iostream>
  #include <memory>
  
  int main()
  {
      std::shared_ptr<int> sharedPtr1 = std::make_shared<int>(42);
      std::shared_ptr<int> sharedPtr2 = std::make_shared<int>(24);
  
      std::weak_ptr<int> weakPtr1 = sharedPtr1;
      std::weak_ptr<int> weakPtr2 = sharedPtr2;
  
      std::cout << "weakPtr1 expired? " << weakPtr1.expired() << std::endl;
      std::cout << "weakPtr2 expired? " << weakPtr2.expired() << std::endl;
  
      weakPtr1 = weakPtr2;
  
      std::cout << "After assignment:" << std::endl;
      std::cout << "weakPtr1 expired? " << weakPtr1.expired() << std::endl;
      std::cout << "weakPtr2 expired? " << weakPtr2.expired() << std::endl;
  
      return 0;
  }
  ```

  赋值操作符执行的是浅拷贝，只复制了 `std::weak_ptr` 对象的内部状态，而没有增加引用计数或改变底层的引用关系。

  在示例代码的输出中，`weakPtr1` 的失效状态（即 `expired()` 返回的值）与 `weakPtr2` 相同，因为它们指向相同的对象。

  使用`operator=`将一个 `std::weak_ptr` 对象赋值给另一个，它们将共享相同的状态信息。

## 相关类和全局函数

---

- **`operator==` 和 `operator!=`**：用于比较两个`unique_ptr`或`shared_ptr`对象是否相等或不相等。

  ```cpp
  std::unique_ptr<int> ptr1(new int(1));
  std::unique_ptr<int> ptr2(new int(2));
  if (ptr1 == ptr2) 
  {
      // ptr1和ptr2指向相同的对象
  }
  ```

  ```c++
  std::shared_ptr<int> ptr1(new int(1));
  std::shared_ptr<int> ptr2(new int(2));
  if (ptr1 == ptr2) 
  {
      // ptr1和ptr2指向相同的对象
  }
  ```

  

- **`operator<`, `operator<=`, `operator>`, `operator>=`**：用于比较两个`unique_ptr`或`shared_ptr`对象的大小关系（按照指针地址比较）。

  ```cpp
  std::unique_ptr<int> ptr1(new int(1));
  std::unique_ptr<int> ptr2(new int(2));
  if (ptr1 < ptr2) 
  {
      // ptr1的指针地址小于ptr2的指针地址
  }
  ```

  ```c++
  std::shared_ptr<int> ptr1(new int(1));
  std::shared_ptr<int> ptr2(new int(2));
  if (ptr1 < ptr2)
  {
     // ptr1的指针地址小于ptr2的指针地址
  }

- **`std::hash`**：计算`shared_ptr`对象的哈希值，用于在哈希容器（如`unordered_map`、`unordered_set`）中使用。

  ```cpp
  std::shared_ptr<int> ptr(new int);
  std::hash<std::shared_ptr<int>> hasher;
  std::size_t hashValue = hasher(ptr); // 计算shared_ptr的哈希值
  ```
  
- **`std::swap`**：用于交换两个智能指针的内容。可以在需要重新分配资源所有权的情况下，高效地交换两个智能指针。

  ```c++
  cppCopy codestd::shared_ptr<int> ptr1 = std::make_shared<int>(42);
  std::shared_ptr<int> ptr2 = std::make_shared<int>(24);
  
  std::swap(ptr1, ptr2);
  ```

- **`std::get_deleter`**：用于获取智能指针中的删除器（deleter）的函数模板。可用于访问存储在特定类型智能指针对象中的删除器。

  删除器是一种用于在智能指针释放资源时执行自定义清理操作的函数对象即仿函数。

  `std::get_deleter`函数接受一个`shared_ptr`指针对象作为参数，并返回对应的删除器的引用。

  它只适用于`std::shared_ptr`共享指针。对于`unique_ptr`作为其成员函数。

  下面是一个示例，演示如何使用`std::get_deleter`函数获取智能指针的删除器：

  ```c++
  #include <memory>
  #include <iostream>
  
  struct Deleter 
  {
      void operator()(int* ptr) 
      {
          std::cout << "Deleting resource: " << *ptr << std::endl;
          delete ptr;
      }
  };
  
  int main() 
  {
      std::shared_ptr<int> sharedPtr(new int(42), Deleter());
  
      Deleter* deleter = std::get_deleter<Deleter, int>(sharedPtr);
      // 或者可以使用自动类型推断
      auto deleter = std::get_deleter<Deleter, int>(sharedPtr);
  
      return 0;
  }
  ```

  在这个示例中，首先定义了一个自定义的删除器`Deleter`，它打印要删除的资源的值，并调用`delete`来释放内存。

  然后，创建了一个`std::shared_ptr`，并将自定义删除器传递给它们。

  接下来，使用`std::get_deleter`来获取智能指针中的删除器。

  最后，可以使用获取到的删除器进行其他操作，例如在需要时手动释放资源。

  注意，`std::get_deleter`的模板参数必须要显式指定删除器类型，智能指针维护的类型可以不显式指定。

  示例（这样的代码也是可以的）：

  ```c++
  #include <memory>
  #include <iostream>
  
  struct Deleter 
  {
      void operator()(int* ptr) 
      {
          std::cout << "Deleting resource: " << *ptr << std::endl;
          delete ptr;
      }
  };
  
  int main() 
  {
      std::shared_ptr<int> sharedPtr(new int(42), Deleter());
      
      auto deleter = std::get_deleter<Deleter>(sharedPtr);//不指定智能指针维护的类型
  
      return 0;
  }
  ```



更多内容请查阅手册或参考这篇文章：[ c++ memory 头文件详细介绍](https://blog.csdn.net/CHYabc123456hh/article/details/109350925)

# `final`关键字

`final`是C++11中引入的一个新关键字，`final`关键字用于指示一个类、函数或虚函数不能被继承、重写或覆盖。

它可以被应用于类的声明、虚函数的声明和函数的声明。

- 防止类被继承

  使用 `final` 关键字修饰的类不能被继承。这意味着其他类无法派生自该类。

  示例：

  ```c++
  class Base final 
  {
      // ...
  };
  
  class Derived : public Base // 错误，无法从 final 类继承
  { 
      // ...
  };
  ```
  
- 防止虚函数被重写

  使用 `final` 关键字修饰的虚函数不能在派生类中被重写或覆盖。

  这在继承体系中可以用于禁止派生类修改某个特定的虚函数。

  示例：

  ```c++
  class Base {
  public:
      virtual void foo() final 
      {
          // ...
      }
  };
  
  class Derived : public Base 
  {
  public:
      void foo() override  // 错误，无法重写 final 虚函数
      { 
          // ...
      }
  };
  ```
  
- 防止普通函数被重写

  使用 `final` 关键字修饰的普通函数（非虚函数）不能在派生类中被重写。它的作用与 `final` 虚函数类似，但它适用于非虚函数。

  示例：

  ```c++
  class Base 
  {
  public:
      void foo() final 
      {
          // ...
      }
  };
  
  class Derived : public Base 
  {
  public:
      void foo() // 错误，无法重写 final 函数
      {  
          // ...
      }
  };
  ```

使用`final`关键字可以在C++中提供额外的控制权，以防止特定类、函数或虚函数被继承、重写或覆盖。

这可以在某些情况下提高代码的安全性和稳定性，以及确保特定实现不会被修改。

# `override`关键字

`override`是C++11中引入的一个新关键字，用于显式地指定某个成员函数为虚函数的重写版本。

当你在派生类中重写基类的虚函数时，可以在该函数的声明后面加上`override`关键字，表示该函数是重写基类的虚函数。

使用`override`关键字有两个好处：

- 它能够帮助你避免一些常见的错误。

  例如：如果你在派生类中重写基类的虚函数时，将函数名或参数列表写错了或者是函数名写错了等。

- 它能够提高代码的可读性。当其他人阅读你的代码时，看到`override`关键字，就能够立即知道这是一个重写基类虚函数的函数。

下面是一个简单的例子，演示如何使用`override`关键字：

```c++
#include <iostream>

class Base 
{
public:
    virtual void foo() 
    {
        std::cout << "Base::foo()" << std::endl;
    }
};

class Derived : public Base 
{
public:
    void foo() override //表示这是函数时重写父类虚函数的
    {
        std::cout << "Derived::foo()" << std::endl;
    }
};

int main() 
{
    Base* b = new Derived();
    b->foo(); // 输出 "Derived::foo()"
    delete b;
    return 0;
}
```

在上面的例子中，我们在派生类`Derived`中重写了基类`Base`的虚函数`foo()`。在重写该函数时，我们在函数声明后面加上了`override`关键字，表示这是一个重写基类虚函数的函数。

# `inline`关键字（内联函数）

内联函数避免了宏函数的一些问题。

内联函数是 C++ 中用来提高函数执行效率的一种方法。它通过在编译时将函数的代码副本放置在每个调用该函数的地方来实现这一目的。

C++ 内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。

对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。

如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字`inline`，在调用函数之前需要对函数进行定义。

==编译器会自动根据函数的开销来选择是否忽略 `inline`限定符。==

==在类定义中的定义的函数都是内联函数，即使没有使用`inline`说明符。==

==内联仅仅只是给编译器一个建议，编译器不一定会接受这种建议==，如果你没有将函数声明为内联函数，那么编译器也可能将此函数做内联编译。

一个好的编译器将会内联小的、简单的函数。

内联函数最适用于小函数，例如访问私有数据成员的函数。这些一行或两行代码的“访问器”函数的主要用途是返回有关对象的状态信息。

内联能提高函数的执行效率，那么为什么不把所有的函数都定义成内联函数呢？
内联以代码膨胀（拷贝）为代价，仅仅省区了函数调用的开销，从而提高程序的执行效率。（开销指的是参数的压栈、跳转、退栈和返回操作）。

一方面，如果执行函数体内代码的时间比函数调用的开销大得多，那么`inline`效率收益会很小。
另一方面，每一处内联函数的调用都要拷贝代码，使程序的总代码量增大，消耗更多的内存空间。
以下情况不宜使用内联：

- 如果函数体内代码比较长，使用内联将导致可执行代码膨胀过大。
- 如果函数体内出现循环或者其他复杂的控制结构，那么执行函数体内代码的时间将比函数调用的开销大得多。

因此，是否设置为内联需要权衡：

- 如果调用开销大于执行开销，则设为内联函数；
- 否则不设为内联函数。



下面是一个简单的内联函数示例，用来返回两个数中的最大值：

```c++
#include <iostream>
using namespace std;

inline int Max(int x, int y) //一个简单的小函数
{
    return (x > y)? x : y;
}

int main() 
{
    cout << "Max (20,10): " << Max(20,10) << endl;
    cout << "Max (0,200): " << Max(0,200) << endl;
    cout << "Max (100,1010): " << Max(100,1010) << endl;
    return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Max (20,10): 20
Max (0,200): 200
Max (100,1010): 1010
```

[内联函数 (C++) | Microsoft Learn](https://learn.microsoft.com/zh-cn/cpp/cpp/inline-functions-cpp?view=msvc-170)
 [c++ 内联函数 （讲解的TM真好） - CSDN博客](https://bing.com/search?q=C%2b%2b+%e5%86%85%e8%81%94%e5%87%bd%e6%95%b0)
[C++ 内联函数 | 菜鸟教程](https://www.runoob.com/cplusplus/cpp-inline-functions.html)
[c++ 内联函数 （讲解的TM真好） - CSDN博客]( https://blog.csdn.net/u011327981/article/details/50601800)
[C++内联函数能否是虚函数？ - 知乎]( https://zhuanlan.zhihu.com/p/37436574)
[ C++内联函数的使用 - 余生以学 - 博客园](https://www.cnblogs.com/2018shawn/p/10851779.html)

对于适合成为内联函数的函数，==编译器会自动添加`inline`关键字使之成为内联函数，大部分场景程序员无需手动添加==，因此内联函数不作重点，基本了解即可，这里不再做过多讲述，详细见上述的图文、视频讲解链接。

# `noexcept`关键字

`noexcept`用于指定函数是不会抛出异常的。这个关键字对于异常处理和代码优化非常有用。

异常接口声明的特性在C++11被移除，在未被移除之前，声明一个不会抛出异常的函数是这样的：

```c++
void func() throw()
{
    //...
}
```

该语法在C++11被移除，C++11后声明一个不会抛出异常的函数就要使用`noexcept`关键字

示例：

```cpp
#include <iostream>

// 声明一个会抛出异常的函数
void mightThrow() 
{
    throw "This function might throw an exception.";
}

// 声明一个不会引发异常的函数
void noThrow() noexcept //noexcept表示函数不会抛出异常
{
    std::cout << "This function will not throw any exception." << std::endl;
}
```

如果，在有`noexcept`修饰的函数中抛出了异常，并且在调用时接收了异常，程序则会出现报错或崩溃。

# `default`关键字

在C++中，`default`关键字用于类中声明默认函数。

类中的默认函数有以下几种：

1. 默认构造函数
2. 默认拷贝构造函数
3. 默认拷贝赋值运算符（重载`=`运算符，参数是左值引用）
4. 默认移动构造函数
5. 默认移动赋值运算符（重载`=`运算符，参数是右值引用）
6. 默认析构函数

默认函数是编译器自动生成的特殊成员函数，用于执行默认的行为。

`default`关键字可以用于以下几个地方：

- 声明默认构造函数

  如果在类中没有显式定义构造函数，或已经手动定义了有参构造函数，那么编译器就不会自动生成一个默认构造函数。

  这时候在创建一个类对象时如果不想立即初始化，就会无法调用默认构造函数，导致编译报错。

  示例：

  ```c++
  class MyClass 
  {
  public:
      MyClass(int x) 
      {
      	a = x;    
      }
  private:
      int a;
  };
  
  int main()
  {
      Myclass A;//编译报错，没有默认构造。因为手动定义了有参构造，编译器不再提供默认构造
  }
  ```

  可以使用`default`关键字来显式声明默认构造函数

  示例：

  ```c++
  class MyClass 
  {
  public:
      MyClass() = default; // 声明默认构造函数
      
      MyClass(int x) 
      {
      	a = x;    
      }
  private:
      int a;
  };
  
  int main()
  {
      Myclass A;//编译通过
  }
  ```

- 声明默认拷贝构造函数

  如果在类中没有显式定义拷贝构造函数，编译器会自动生成一个默认拷贝构造函数。

  可以使用`default`关键字来显式声明默认拷贝构造函数

  例如：

  ```c++
  class MyClass 
  {
  public:
      MyClass(const MyClass& other) = default; // 声明默认拷贝构造函数
  };
  ```

- 声明默认拷贝赋值运算符

  ```c++
  class MyClass 
  {
  public:
      MyClass& operator=(const MyClass& other) = default; // 声明默认拷贝赋值运算符
  };
  ```

- 声明默认移动构造函数

  C++11引入了移动语义，可以通过移动构造函数和移动赋值运算符实现高效的资源管理。

  如果在类中没有显式定义移动构造函数和移动赋值运算符，编译器会自动生成默认的移动构造函数和移动赋值运算符。

  可以使用`default`关键字来显式声明默认移动构造函数和移动赋值运算符，

  例如：

  ```c++
  class MyClass 
  {
  public:
      MyClass(MyClass&& other) = default; // 声明默认移动构造函数
  };
  ```

- 声明默认移动赋值运算符

  ```c++
  class MyClass 
  {
  public:
      MyClass& operator=(MyClass&& other) = default; // 声明默认移动赋值运算符
  };
  ```

- 声明默认析构函数

  如果在类中没有显式定义析构函数，编译器会自动生成一个默认析构函数。

  可以使用`default`关键字来显式声明默认析构函数。

  例如：

  ```c++
  class MyClass 
  {
  public:
      ~MyClass() = default; // 声明默认析构函数
  };
  ```

`default`也可以在类外使用。

示例：

```c++
class MyClass 
{
public:
    MyClass();
};
MyClass::MyClass() = default;
```

通过使用`default`关键字，可以显式声明使用编译器生成的默认函数，这对于需要手动定义其他函数而又需要默认函数的情况非常有用。

# `=delete`禁用函数

为了能够让程序员显式的禁用某个函数，C++11标准引入了一个新特性：使用`=delete`修饰函数。

只需在函数声明后上`=delete`，就可将该函数禁用。

示例：

```c++
class MyClass 
{
public:
    // 禁用默认构造函数
    MyClass() = delete;

    // 禁用拷贝构造函数
    MyClass(const MyClass&) = delete;

    // 禁用拷贝赋值运算符
    MyClass& operator=(const MyClass&) = delete;

    // 禁用析构函数
    ~MyClass() = delete;

    // 禁用特定的成员函数
    void doSomething() = delete;
};

int main() 
{
    MyClass obj; // 编译错误，禁用了默认构造函数

    MyClass obj1;
    MyClass obj2 = obj1; // 编译错误，禁用了拷贝构造函数

    obj1 = obj2; // 编译错误，禁用了拷贝赋值运算符

    obj1.doSomething(); // 编译错误，禁用了特定的成员函数

    return 0;
}

```

# 使用`using`取别名

在C++11中，使用`using`关键字可以用来为类型创建别名。

它与`typedef`有一些区别，下面是它们之间的主要区别：

- 语法：

  `using`语法相对更加直观和一致。

  它使用类似于变量赋值的语法，如`using NewName = OldType;`

  而`typedef`则使用一个稍微有些独特的语法，如`typedef OldType NewName;`

- 支持模板别名：

  `using`关键字支持为模板类型创建别名，

  例如：

  ```c++
  template <typename T>
  using Vector = std::vector<T>;
  ```

  这里`Vector`是`std::vector`的别名，它可以用来创建具有相同类型元素的向量。

- 嵌套类型别名：`using`关键字可以在类内部为嵌套类型创建别名，而`typedef`不能直接在类内部使用，需要借助`typedef`在类外部进行定义。
- 模板参数位置：在模板定义时，`using`关键字可以在任意位置指定模板参数，而`typedef`只能在定义之前指定模板参数。
- 右结合性：`using`关键字的右结合性使得它更容易使用模板元编程和模板别名的复杂技术。

`using`关键字在C++11中提供了更加灵活和直观的方式来创建类型别名，并且它还支持模板别名和嵌套类型别名，这些是`typedef`所没有的特性。

因此，推荐使用`using`关键字来创建类型别名。但为了保持与旧代码的兼容性，`typedef`仍然被广泛使用。

# 函数模板的默认模板参数

C++11前类模板是支持默认的模板参数的，却不支持函数模板的默认模板参数。

```c++
//1、普通函数带默认参数，c++98编译通过，c++11编译通过
void DefParm(int m=3){}

//2、类模板是支持默认的模板参数，c++98编译通过，c++11编译通过
template <typename T = int>class DefClass;

//3、函数模板的默认模板参数，c++98-编译失败，c++11-编译通过
template <typename T= int> void DefTempParm(){}
```

  类模板的默认模板参数必须从右往左定义，数模板的默认模板参数则没这个限定：

```c++

template <typename T ,class T2= int>class DefClass{};//编译正确

template <typename T= int ,class T2>class DefClass{};//编译错误

template<class T1 = int, class T2> void DefFunc1(T1 a,T2 b){};//函数模板无限制，编译通过
```



# 可变参数模板

## 可变参数函数模板

C++11引入了可变参数模板（Variadic Templates）的特性，它允许在模板中接受任意数量的参数。

这个特性非常有用，因为它可以用于编写更加通用和灵活的代码。

变参数模板使用`...`语法来表示：

```c++
template<class ...T>//T叫模板参数包
void func (T... args) // args叫函数参数包
```

示例：

```c++
#include <iostream>
using namespace std;

//可变参数的模板函数
template<class ... T>//T叫模板参数包
void func (T... args) //args叫函数参数包
{
}
int main ()
{
	func<int> (10);
	func<int, int> (10,20);
    func<char, int> (10, 'a' );
	func<char,char *, int> ('a', "abc",250);
    return 0;
}
```

上面的代码编译是可以通过的。

一个使用可变参数模板的函数模板的例子：

```cpp
#include <iostream>

// 基本情况：当没有参数时，递归终止
void print() 
{
    std::cout << std::endl;
}

// 递归调用：打印第一个参数，然后调用自身打印剩余参数
template<typename T, typename... Args>
void print(const T& first, const Args&... args) 
{
    std::cout << first << " ";
    print(args...);
}

int main() 
{
    print(1, "Hello", 3.14, 'A');
    return 0;
}
```

输出：

```
1 Hello 3.14 A
```

在上面的代码中，我们定义了一个可变参数模板函数`print`，它可以接受任意数量的参数并将它们打印到标准输出。

在递归调用中，我们首先打印第一个参数`first`，然后通过`args...`将剩余的参数传递给自身进行递归调用。

当我们在`main`函数中调用`print`函数时，我们传递了四个参数：

整数1，字符串"Hello"，浮点数3.14和字符'A'。

由于`print`函数是可变参数模板，它能够接受这四个参数并将它们全部打印出来。

## 可变参数类模板

除了函数模板，我们还可以使用可变参数模板来定义类模板。

以下是一个简单的示例：

```cpp
#include <iostream>

template<typename... Args>
class Tuple 
{
public:
    Tuple(const Args&... args) : values{args...} {}

    void print() 
    {
        printHelper(values);
        std::cout << std::endl;
    }

private:
    template<typename T>
    void printHelper(const T& value)
    {
        std::cout << value << " ";
    }

    template<typename T, typename... Rest>
    void printHelper(const T& first, const Rest&... rest) 
    {
        std::cout << first << " ";
        printHelper(rest...);
    }

    std::tuple<Args...> values;
};

int main() 
{
    Tuple<int, std::string, double> t(42, "Hello", 3.14);
    t.print();
    return 0;
}
```

在上面的代码中，我们定义了一个名为`Tuple`的类模板，它使用可变参数模板来接受任意数量的类型参数。

在构造函数中，我们将传递的参数打包成一个`std::tuple`对象来保存。

类模板中的`print`函数使用递归的方式打印保存的值。

我们使用类内嵌的辅助函数`printHelper`来实现递归，类似于前面函数模板的例子。

在`main`函数中，我们创建了一个`Tuple`对象，类型参数为`int`，`std::string`和`double`，并传递了相应的值。

然后，我们调用`print`函数来打印这些值。

输出结果将是：`42 Hello 3.14`。

## 获取可变参数模板的参数个数

使用`sizeof...(Args)`可以获取可变参数模板的参数个数。

`sizeof...()`是一个C++的运算符，用于计算可变参数模板的参数个数。

它返回一个`size_t`类型的值，表示参数的数量。

```c++
#include <iostream>
using namespace std;
//可变参数的模板函数
template<class ... T>//T叫模板参数包
void func (T... args) //args叫函数参数包
{
	//获取可变参数的个数
	cout <<"num = " <<sizeof.. . (args) <<endl;
}
int main ()
{
	func<int> (10);
	func<int, int> (10,20);
    func<char, int> (10, 'a' );
	func<char,char *, int> ('a', "abc",250);
    return 0;
}
```

输出：

```
num = 1
num = 2
num = 2
num = 3
```

需要注意的是，`sizeof...(Args)`是在编译时计算的，因此它提供了在编译期间获取参数个数的能力。这使得可以在编译时进行相关的优化和决策。

## 模板特化

模板特化（Template specialization）是C++中一种用于为特定类型或特定模板参数提供自定义实现的机制。

它允许我们根据特定的类型或参数来定义特定版本的模板函数或模板类，以满足特定的需求或提供特定的行为。

模板特化可以分为两种类型：全特化（Full specialization）和偏特化（Partial specialization）。

- 全特化（Full specialization）：全特化是针对特定类型或特定参数的完整定义。在全特化中，我们提供了特定类型或参数的实现，完全替代了原始的模板定义。全特化的语法形式为：
   ```cpp
   template<typename T>
   struct MyTemplate {
       // 通用实现
   };
   
   template<>
   struct MyTemplate<int> {
       // int 类型的特化实现
   };
   ```

   在上述示例中，我们定义了一个通用的模板类`MyTemplate`，并通过全特化为`int`类型提供了一个特殊的实现。

- 偏特化（Partial specialization）：偏特化是针对模板参数的部分定义。它允许我们根据参数的特定属性或限制来提供不同的实现。偏特化的语法形式为：
   ```cpp
   template<typename T, typename U>
   struct MyTemplate {
       // 通用实现
   };
   
   template<typename T>
   struct MyTemplate<T, int> {
       // T 和 int 类型的偏特化实现
   };
   ```

   在上述示例中，我们定义了一个通用的模板类`MyTemplate`，并通过偏特化为`T`和`int`类型的组合提供了一个特殊的实现。

模板特化使我们能够为特定的类型或参数提供自定义的行为，以满足特殊的需求或提供更精确的实现。

它在泛型编程中起到了非常重要的作用，并且是C++模板系统的强大功能之一。

## 函数模板参数包的展开

### 递归和模板特化展开

通过递归函数展开参数包，需要提供一个参数包展开的函数和一个递归终止函数。

示例代码：

```c++
#include <iostream>
using namespace std;

//当最后没有参数时调用这个
//递归终止函数1
void debug ()
{
	cout << "empty" << endl;
}

/*也可以这样写，当最后只有一个参数时调用这个函数
//递归终止函数2
template<class T>
void debug (T tmp)
{
	cout <<"tmp = " <<tmp <<endl ;
}
*/
//以此类推，可以根据需要指定递归终止函数的调用参数

//可变参数的模板函数
//参数包展开函数
template<class T1,class ... T2>
void debug (T1 first,T2... last)
{
	cout << first << endl;//递归调用函数本身
	debug ( last... );
}

int main ()
{
	debug ( 1, 2,3, 4) ;
	 /*	函数递归调用过程:
		debug (1，2，3,4);
		debug (2，3,4);
		debug (3,4) ;
		debug (4);
		debug ();	*/
}
```

### 递归、逗号和初始化列表展开

使用场景较少，不推荐使用

```c++
#include <iostream>
using namespace std;

template<class T>
void print (T tmp)
{
	cout << tmp << endl;
}
//可变参数的模板函数
template<class ...T>
void expand(T ... args)
{
	//逗号运算符
    //初始化列表
	int a[] = { (print (args), 0) ...};
}
int main ()
{
	expand (1,2,3,4);
	return 0;
}
```

### 折叠表达式（C++17起）展开

```c++
template<typename... Args>
void baz()
{
	// 使用折叠表达式展开参数包
	((std::cout << typeid(Args).name() << std::endl), ...);
}

int main()
{
	baz<int, double, char*, std::vector<std::list<int, std::string>>>();
	return 0;
}
```

输出（因为屏幕长度显示，最后三行换行了）：

```
int
double
char * __ptr64
class std::vector<class std::list<int,class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > >,class std::allocator<class std::list<int,class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> > > > >
```

## 类模板参数包的展开

### 继承方式展开

继承方式展开可变参数模板类的步骤：

- 可变参数模板声明
- 递归继承模板类
- 递归终止条件

示例：

```c++
//1.可变参数模板声明
template<class...T>class Car {};

//2.递归继承模板类本身
template<class Head, class ...Tail>
class Car<Head, Tail...> :public Car<Tail...>
{
public:
	Car()
	{
		std::cout << "type = " << typeid(Head).name() << std::endl;
	}
};

//3.递归终止条件
template<>
class Car<> {};

int main ()
{    
	Car<int, std::string, const char*, bool> byd;
	return 0;
}
```

输出：

```
type = bool
type = char const * __ptr64
type = class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >
type = int
```

### 递归和特例化展开

- 变长模板声明
- 变长模板类定义
- 递归终止

示例：

```c++
//1.变长模板声明
template<int ...last>
class Test {};

//2.变长模板类定义
template<int first, int ...last>
class Test<first, last...>
{
public:
	static const int val = first * Test<last...>::val;
};

//3.递归终止
template<>
class Test<>
{
public:
	static const int val = 1;
};


int main ()
{    
	std::cout << Test<2, 3, 4, 5>::val << std::endl;

	return 0;
}
```

### 折叠表达式（C++17起）展开

```c++
template<typename... Args>
class MyTemplate
{
public:
	void process()
	{
		// 使用折叠表达式展开参数包
		((std::cout << typeid(Args).name() << std::endl), ...);
	}
};

int main()
{

	MyTemplate<int, char, std::string, const char*> test;
	test.process();
	return 0;
}
```

输出：

```
int
char
class std::basic_string<char,struct std::char_traits<char>,class std::allocator<char> >
char const * __ptr64
```

